#+TITLE: Doom Emacs Configuration
#+AUTHOR: Jan Felix Langenbach
#+EMAIL: o.hase3@gmail.com
#+DESCRIPTION: Doom Emacs configuration of Jan Felix Langenbach
#+LANGUAGE: en
#+STARTUP: fold
#+PROPERTY: header-args :lexical yes :results silent :tangle yes

* Introduction
These are some useful links to manuals and other peoples configs.

+ [[https://www.gnu.org/software/emacs/manual][Emacs Manual]]
+ [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]]
+ [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
+ [[https://github.com/MatthewZMD/.emacs.d][M-Emacs]]
+ [[https://github.com/poncie/.emacs.d][Poncie’s Config]]
+ [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua’s Config]]
+ [[http://aaronbedra.com/emacs.d/#languages][Aaron Bedra’s Config]]
+ [[https://dotdoom.rgoswami.me/config.html][Rohit Goswami’s Config]] (Very Old)

** Header
This header comment ensures that everything in this file is lexically scoped.
#+BEGIN_SRC emacs-lisp
;;; doom/config.el -*- lexical-binding: t; -*-
#+END_SRC

** Requires
*** [[https://github.com/magnars/dash.el][dash.el]]
A modern list library inspired by Clojure.
#+BEGIN_SRC emacs-lisp
(require 'dash)
#+END_SRC

*** [[https://github.com/purcell/reformatter.el][reformatter.el]]
A library for creating formatting functions.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :editor fmt)
  (require 'reformatter))
#+END_SRC

** Snippets
:PROPERTIES:
:header-args+: :tangle no :lexical yes
:END:
This snippet returns the status of ~lexical-binding~.
#+BEGIN_SRC emacs-lisp
(defun lex-p ()
  "Return t if lexical binding is in effect."
  (let (lex _lex-p)
    (let ((lex t))
      (setq _lex-p (lambda () lex)))
    (funcall _lex-p)))

(if (lex-p) "Yes" "No")
#+END_SRC

* Definitions
** Functions and Macros
#+BEGIN_SRC emacs-lisp
(defmacro async! (&rest body)
  "Evaluate BODY asynchronously for side-effects only."
  (declare (indent 1))
  `(async-start (lambda () ,@body) #'ignore))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun string-or (&rest strings)
  "Return the first non-nil and non-empty string in STRINGS."
  (declare (pure t) (side-effect-free t))
  (cl-dolist (s strings)
    (when (and s (not (string-empty-p s)))
      (cl-return s))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun sys-feature-p (feature)
  "Return t if FEATURE is available on this system."
  (memq feature SYS-FEATURES))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro push! (place &rest values)
  "Push VALUES into PLACE."
  `(setf ,place (nconc (list ,@values) ,place)))
#+END_SRC

** Commands
#+BEGIN_SRC emacs-lisp
(defun comments-to-column (&optional column)
  "Move any end-of-line comments to COLUMN or `comment-column'."
  (interactive "*")
  (let ((beg (if (doom-region-active-p)
                 (doom-region-beginning)
               (line-beginning-position)))
        (end (if (doom-region-active-p)
                 (doom-region-end)
               (line-end-position)))
        (column (or column comment-column)))
    (save-excursion
      (goto-char beg)
      (while (< (point) end)
        (beginning-of-line)
        (when (looking-at ".*\\s-\\(\\s<\\)")
          ;; Go to the last comment starter preceded by whitespace.
          (goto-char (match-beginning 1))
          ;; Delete all whitespace before point.
          (delete-char (abs (skip-syntax-backward "\\s-")))
          (indent-to column 1))
        (forward-line 1)))))
#+END_SRC

** Constants
*** System
#+BEGIN_SRC emacs-lisp
(defconst SYSTEM
  (let ((sysname (system-name)))
    (cond ((string= sysname "PhantomJFL") 'Phantom)
          ((string= sysname "TeslaJFL")   'Tesla)
          (t 'other)))
  "Which system are we running on?")
#+END_SRC

I redefine the operating system constants of Doom Emacs to give them docstrings.
#+BEGIN_SRC emacs-lisp
(defconst IS-LINUX IS-LINUX
  "Are we on a Linux system?")

(defconst IS-MAC IS-MAC
  "Are we on a Mac?")

(defconst IS-WINDOWS IS-WINDOWS
  "Are we on a Windows system?")

(defconst IS-BSD IS-BSD
  "Are we on a BSD system?")
#+END_SRC

*** Environment
These constants allow me to use the correct directories everywhere,
without lengthy invocation of =getenv=.
#+BEGIN_SRC emacs-lisp
(defconst XDG-DATA-HOME
  (-> (getenv "XDG_DATA_HOME")
      (string-or "~/.local/share/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_DATA_HOME where programs store data.")

(defconst XDG-CONFIG-HOME
  (-> (getenv "XDG_CONFIG_HOME")
      (string-or "~/.config/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CONFIG_HOME where programs place configuration files.")

(defconst XDG-CACHE-HOME
  (-> (getenv "XDG_CACHE_HOME")
      (string-or "~/.cache/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CACHE_HOME where programs place cache files.")

(defconst SYS-FEATURES
  (mapcar #'intern (-> (getenv "SYS_FEATURES")
                       (or "") (split-string ":")))
  "A list of symbols which represent system features.")
#+END_SRC

* General Configuration
Don’t untabify when deleting a tab character.
#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC

Make the block cursor stretch to highlight tab characters.
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

Make the output buffer of ~shell-command~ a popup buffer.
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "^\\*Shell Command Output\\*$" :quit t)
#+END_SRC

** Custom.el
Move the ~customize~ blocks into =custom.el=.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" doom-private-dir))
#+END_SRC

** Doom Emacs
Don’t turn on ~whitespace-mode~ automatically.
#+BEGIN_SRC emacs-lisp
(defadvice! *doom--disable-automatic-whitespace-mode-a (&rest _)
  "Don’t turn on `whitespace-mode' on startup."
  :after #'doom-init-ui-h
  (remove-hook 'after-change-major-mode-hook
               #'doom-highlight-non-default-indentation-h))
#+END_SRC

Define these variables from =core/autoload/config.el=.
#+BEGIN_SRC emacs-lisp
(setq doom-bin-dir (concat doom-emacs-dir "bin/")
      doom-bin     (concat doom-bin-dir   "doom"))
#+END_SRC

** Fonts
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Source Code Pro" :size 13)
      doom-serif-font (font-spec :family "Source Serif Pro")
      doom-variable-pitch-font (font-spec :family "Source Sans Pro"))
#+END_SRC

** Hideshow
#+BEGIN_SRC emacs-lisp
(map! :after hideshow
      :map hs-minor-mode-map
      :leader :prefix ("c h" . "Hide code")
      :desc "Toggle hiding"    "h" #'hs-toggle-hiding
      :desc "Hide all"         "a" #'hs-hide-all
      :desc "Show all"         "A" #'hs-show-all
      :desc "Hide block"       "b" #'hs-hide-block
      :desc "Show block"       "B" #'hs-show-block
      :desc "Hide level"       "l" #'hs-hide-level
      :desc "Hide top comment" "c" #'hs-hide-initial-comment-block)
#+END_SRC

** HL Line Mode
While ~hl-line-mode~ is active, ~face-at-point~ always returns ~hl-line~.
This advice unhighlights the current line before ~face-at-point~ is called.
#+BEGIN_SRC emacs-lisp
(after! hl-line
  (defadvice! *hl-line--fix-face-at-point-a (orig-fn &rest args)
    :before #'face-at-point
    (when hl-line-mode
      (hl-line-unhighlight))))
#+END_SRC

** Info
Treat ~info~ buffers as real buffers.
#+BEGIN_SRC emacs-lisp
(after! info (set-popup-rule! "^\\*info\\*$" :ignore))
#+END_SRC

** Theme
Set the color theme. On =Tesla= I currently use light themes.
#+BEGIN_SRC emacs-lisp
(setq doom-theme
      (cl-case SYSTEM
        ('Phantom 'doom-one)
        ('Tesla   'doom-one-light)
        (t        'doom-one)))
#+END_SRC

** Visual Line Mode
#+BEGIN_SRC emacs-lisp
(defun turn-off-visual-line-mode ()
  (interactive)
  (visual-line-mode -1))
#+END_SRC

** Whitespace Mode
#+BEGIN_SRC emacs-lisp
(after! whitespace
  (setq whitespace-style
        '(face
          indentation
          lines-tail
          empty
          tabs
          tab-mark
          space-before-tab
          space-after-tab)))
#+END_SRC

* Emacs 27 Features
** Fill Column Indicator
#+BEGIN_SRC emacs-lisp
(when EMACS27+
  (add-hook! '(prog-mode-hook text-mode-hook)
             #'display-fill-column-indicator-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when EMACS27+
  (defun display-fill-column-indicator-mode--turn-off ()
    (interactive)
    (display-fill-column-indicator-mode -1)))
#+END_SRC

** Tab Bar
For ~tab-line~ configuration, steal from [[https://gitlab.com/andreyorst/dotfiles/-/blob/master/.config/emacs/init.el][andreyorst]].

Wrap everything in a conditional. Disabled because WIP.
#+BEGIN_SRC emacs-lisp :tangle no
(when EMACS27+
  (after! tab-bar))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(setq tab-bar-close-button-show t
      tab-bar-new-button-show t
      tab-bar-separator nil
      tab-bar-tab-name-ellipsis "…"
      tab-bar-tab-name-truncated-max 20
      tab-bar-tab-name-function #'tab-bar-tab-name-truncated
      tab-bar-close-button (propertize
                            (if (char-displayable-p ?×) " × " " x ")
                            'close-tab t
                            :help "Click to close tab"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(let ((fg   (face-attribute 'default   :foreground))
      (bg   (face-attribute 'default   :background))
      (base (face-attribute 'mode-line :background)))
  (set-face-attribute
   'tab-bar nil
   :foreground fg
   :background bg
   :box (list :line-width -1 :color base))
  (set-face-attribute
   'tab-bar-tab nil
   :foreground fg
   :background bg
   :box (list :color bg)
   )
  (set-face-attribute
   'tab-bar-tab-inactive nil
   :foreground fg
   :background base
   :box (list :color base)))
#+END_SRC

* Editor Features
** File Templates
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :editor file-templates)
  (defvar +file-templates-fallback-dir +file-templates-dir
    "The directory where the file templates provided by Doom are stored.")

  (setq +file-templates-dir (expand-file-name "templates/" doom-private-dir))

  (after! yasnippet
    (setq yas-snippet-dirs
          (nconc (when (featurep! :editor snippets) '(+snippets-dir))
                 '(+file-templates-dir)
                 (->> yas-snippet-dirs
                      (delq '+snippets-dir)
                      (delq '+file-templates-dir))
                 '(+file-templates-fallback-dir)))))
#+END_SRC

** Formatting Engine
I replace the default formatting function with my own.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor fmt)
      :nv "g =" #'+fmt:region
      :map doom-leader-code-map
      :desc "Format buffer/region" "f" #'+fmt/dwim)
#+END_SRC

** Form Feed
This mode displays instances of =^L= (form feed) as horizontal lines.
#+BEGIN_SRC emacs-lisp
(use-package! form-feed
  :hook ((prog-mode text-mode) . form-feed-mode))
#+END_SRC

*** Keybindings
Allows jumping from =^L= to =^L=.
#+BEGIN_SRC emacs-lisp
(map! "C-M-<next>"  #'forward-page
      "C-M-<prior>" #'backward-page)
#+END_SRC

** Indentation
*** Indent Guides
The package [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]] draws a line for each indentation level.
#+BEGIN_SRC emacs-lisp :tangle yes :noweb-ref :noweb no-export
(use-package! highlight-indent-guides
  ;; Maybe change this to mode-by-mode basis.
  :commands (highlight-indent-guides-mode)
  :config
  ;; Use bitmap images instead of characters.
  (setq highlight-indent-guides-method 'bitmap)
  ;; Use a bitmap of a solid line.
  (setq highlight-indent-guides-bitmap-function
        #'highlight-indent-guides--bitmap-line)
  ;; Highlight the nearest indent guide.
  (setq highlight-indent-guides-responsive 'top))
#+END_SRC

*** Indent Level
Indentation in Emacs is a mess currently. Each mode defines its own variables.
This consolidates indentation into one single variable.
#+BEGIN_SRC emacs-lisp
(defvar-local indent-level 4
  "Indentation level for all major-modes.")

(defvaralias 'standard-indent 'indent-level)
#+END_SRC

*** Tabs for Indentation
Disable tab insertion by default. It will be enabled manually for each mode.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC

These functions have a tendency to insert tabs where they don’t belong.
#+BEGIN_SRC emacs-lisp
(defadvice! *emacs--disable-indent-tabs-mode-a (orig-fn &rest args)
  "Let `indent-tabs-mode' be bound to nil."
  :around '(align-areas comment-indent indent-relative)
  (let (indent-tabs-mode) (apply orig-fn args)))
#+END_SRC

** Language Server Protocol
*** TODO Try semantic highlighting.
#+BEGIN_SRC emacs-lisp :tangle no
(setq lsp-enable-semantic-highlighting t)
#+END_SRC

** Literate Configuration
Make use of =async.el= to tangle =config.org= in a separate process without
blocking the main thread.
#+BEGIN_SRC emacs-lisp
(when (featurep! :config literate)

  (defvar *literate-tangle-in-progress-p nil
    "Contains a future of a currently tangling process or nil.")

  (defadvice! *literate-tangle-async-a (&optional force-p)
    "Compile `+literate-config-file' in an async process."
    :override #'+literate-tangle-h
    (let ((default-directory doom-private-dir))
      (when (or force-p (file-newer-than-file-p +literate-config-file
                                                +literate-config-cache-file))
        (print! (start "Compiling your literate config..."))
        (let ((org  (expand-file-name +literate-config-file))
              (dest (concat (file-name-sans-extension +literate-config-file) ".el"))
              (cache +literate-config-cache-file))
          (when-let* ((proc *literate-tangle-in-progress-p)) (async-wait proc))
          (setq *literate-tangle-in-progress-p
                (async-start
                 (lambda ()
                   (and (require 'ob-tangle)
                        (org-babel-tangle-file org dest)
                        (with-temp-file cache)))
                 (lambda (&rest _)
                   (message "Compilation finished!")
                   (-some-> (expand-file-name dest)
                     (find-buffer-visiting)
                     (with-current-buffer (revert-buffer 'ignore-auto 'noconfirm)))
                   (setq *literate-tangle-in-progress-p nil)))))))))
#+END_SRC

*** NOTE: Is explicit sync really needed?
Maybe I should remove ~*literate-tangle-in-progress-p~, as the tangling process
is currently fast enough to make race conditions unlikely.

** Spell Checking
*** Ispell
#+BEGIN_SRC emacs-lisp
(setq ispell-dictionary "en_US")
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
(remove-hook 'prog-mode-hook #'flyspell-mode)
#+END_SRC

** Terminal
*** Shell
*** EShell
*** Term
*** VTerm
This hack removes a problematic popup rule.
#+BEGIN_SRC emacs-lisp
(setq display-buffer-alist (assoc-delete-all "^vterm" display-buffer-alist))
#+END_SRC

VTerm doesn’t recognize any keypad keys for some reason. This advice translates
the keypad keycodes into the corresponding keyboard keycodes.
#+BEGIN_SRC emacs-lisp
(defadvice! *vterm--add-keypad-keys-a (args)
  "Make `vterm' recognize `<kp-*>' sequences by translating them."
  :filter-args #'vterm-send-key
  (let ((key (car args)))
    (when (string-prefix-p "<kp-" key)
      (setq key (substring key 4 -1))
      (when (> (length key) 1)
        (setq key (cond ((string= key "add"      ) "+")
                        ((string= key "subtract" ) "-")
                        ((string= key "multiply" ) "*")
                        ((string= key "divide"   ) "/")
                        ((string= key "separator") ",")
                        (t key))))
      (setf (car args) key))
    args))
#+END_SRC

** Tree View
*** Neotree
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :ui neotree)
      :after neotree
      :map neotree-mode-map
      :n "<tab>" #'neotree-quick-look)
#+END_SRC

*** Treemacs
** Undo/Redo
*** Undo Fu
*** Undo Tree
When =undo-tree= is allowed to automatically save the undo history, it somehow
chokes on an empty undo list and interrupts us with constant errors.
#+BEGIN_SRC emacs-lisp
(setq undo-tree-auto-save-history nil)
#+END_SRC

*** Keybindings
Bind keys for ~redo~.
#+BEGIN_SRC emacs-lisp
(map! "<redo>" #'redo
      :n "U" #'redo)
#+END_SRC

* Packages
** Company
*** Quickhelp
#+BEGIN_SRC emacs-lisp
(use-package! company-quickhelp
  :when (featurep! :completion company)
  :after company
  :hook (company-mode-hook . company-quickhelp-local-mode)
  :config (setq company-quickhelp-use-propertized-text nil))
#+END_SRC

** Evil
*** Evil Mode
Evil uses Vim’s undo increments by default, which are too coarse for me.
#+BEGIN_SRC emacs-lisp
(setq evil-want-fine-undo t)
#+END_SRC

Automatic conversion of tabs seems to be broken.
#+BEGIN_SRC emacs-lisp
(setq evil-indent-convert-tabs nil)
#+END_SRC

We can’t use ~defvaralias~ here, because ~evil-mode~ is already running
which causes ~evil-shift-width~ to be a localized variable.
#+BEGIN_SRC emacs-lisp
;; (defvaralias 'evil-shift-width 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil
      ;; Remap the document scroll motions to something more sensible.
      :m "z+" nil
      :m "z-" nil
      :m "z^" nil
      :m "z." nil
      :m "zT" #'evil-scroll-bottom-line-to-top
      :m "zB" #'evil-scroll-top-line-to-bottom
      :m "z S-<right>" #'evil-scroll-right
      :m "z S-<left>" #'evil-scroll-left
      ;; Map the arrow keys in Evils window map.
      (:map evil-window-map
       "<up>"      #'evil-window-up
       "<down>"    #'evil-window-down
       "<left>"    #'evil-window-left
       "<right>"   #'evil-window-right
       "S-<up>"    #'+evil/window-move-up
       "S-<down>"  #'+evil/window-move-down
       "S-<left>"  #'+evil/window-move-left
       "S-<right>" #'+evil/window-move-right
       "C-h"       nil
       "C-j"       nil
       "C-k"       nil
       "C-l"       nil))
#+END_SRC

*** Evil Collection
Doom Emacs loads the ~evil-collection~ packages manually and needs the
corresponding variables to be set beforehand. The code below runs
right before ~+evil-collection-init~ first called.
#+BEGIN_SRC emacs-lisp :noweb no-export
(when (and (featurep! :editor evil +everywhere)
           doom-interactive-p
           (not doom-reloading-p)
           (not (memq 'evil-collection doom-disabled-packages)))
  (add-transient-hook! #'+evil-collection-init
    (push! +evil-collection-disabled-list
           'tetris '2084-game 'haskell-error-mode)))
#+END_SRC

*** Evil Matchit
#+BEGIN_SRC emacs-lisp
(use-package! evil-matchit
  :when (featurep! :editor evil)
  :after-call pre-command-hook
  :init (setq evilmi-shortcut "%")
  :config (global-evil-matchit-mode +1))
#+END_SRC

*** Evil Numbers
Remap the ~inc-at-pt~ functions, so =z == can be used for formatting.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-numbers
      :nv "g +" #'evil-numbers/inc-at-pt
      :nv "g -" #'evil-numbers/dec-at-pt
      :v  "z +" #'evil-numbers/inc-at-pt-incremental
      :v  "z -" #'evil-numbers/dec-at-pt-incremental)
#+END_SRC

*** Evil Snipe
Put ~evil-snipe-repeat~ on Comma and Shift-Comma.
Doesn’t seem to work due to keymap precedences.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-snipe
      :map evil-snipe-parent-transient-map
      "," #'evil-snipe-repeat
      "–" #'evil-snipe-repeat-reverse
      ";" nil)
#+END_SRC

*** Evil Org
The =evil-org= package is only loaded when the =+everywhere= flag is set.

Doom Emacs changes ~org-cycle~ to skip the =subtree= stage by default when
~(featurep! :editor evil +everywhere)~.
#+BEGIN_SRC emacs-lisp
(after! evil-org
  (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h))
#+END_SRC

Add block jumping to =[= and =]= and remap =z r= and =z m= to =z O= and =z C=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-org
      :map evil-org-mode-map
      :m "[ _" #'org-previous-block
      :m "] _" #'org-next-block
      :n "z r" nil
      :n "z m" nil
      :n "z O" #'+org/show-next-fold-level
      :n "z C" #'+org/hide-next-fold-level)
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :checkers syntax)
      :after flycheck
      ;; Map double exclamation mark.
      (:map flycheck-command-map "!" #'flycheck-buffer)
      ;; Name the flycheck prefix keys.
      (:leader :prefix "c"
       (:prefix ("!" . "flycheck") "" flycheck-command-map))
      (:map flycheck-mode-map :prefix "C-c"
       (:prefix ("!" . "flycheck") "" flycheck-command-map)))
#+END_SRC

** Helpful
Some function definitions contain tab character that are
assumed to be eight spaces wide.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'helpful-mode-hook
  tab-width 8
  x-stretch-cursor nil)
#+END_SRC

** Hungry Delete
These functions delete all whitespace up to the next non-whitespace character.
#+BEGIN_SRC emacs-lisp
(use-package! hungry-delete
  :bind (("M-DEL"      . hungry-delete-backward)
         ("M-<delete>" . hungry-delete-forward)))
#+END_SRC

** Ivy
Don’t show =../= in file completion buffer.
#+BEGIN_SRC emacs-lisp
(setq ivy-extra-directories '("./"))
#+END_SRC

Ivy should recurse into directories when pressing =RET=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :completion ivy)
      :after ivy
      :map ivy-minibuffer-map
      "<return>"   #'ivy-alt-done
      "C-<return>" #'ivy-immediate-done
      "C-l"        #'ivy-done
      "C-<up>"     #'ivy-previous-history-element
      "C-<down>"   #'ivy-next-history-element)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
(add-hook   'git-commit-setup-hook #'turn-off-flyspell)
(setq-hook! 'git-commit-setup-hook fill-column 50)
#+END_SRC

** Org
*** Org Mode
#+BEGIN_SRC emacs-lisp
(setq org-cycle-global-at-bob t
      org-cycle-include-plain-lists nil
      org-directory (expand-file-name "~/text/org/")
      org-startup-folded t)
#+END_SRC

Use hard line wrapping to keep all columns shorter than ~fill-column~.
#+BEGIN_SRC emacs-lisp
(add-hook! 'org-mode-hook #'turn-off-visual-line-mode #'auto-fill-mode)
#+END_SRC

Don’t start ~flyspell-mode~ automatically.
#+BEGIN_SRC emacs-lisp
(remove-hook 'org-mode-hook #'flyspell-mode)
#+END_SRC

Add ~company-capf~ as a Company backend.
#+BEGIN_SRC emacs-lisp
(set-company-backend! 'org-mode 'company-capf)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (sp-local-pair 'org-mode "=" "=")
  (sp-local-pair 'org-mode "~" "~"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'org-mode
    "C-c C-x" "more"
    "C-c C-v" "babel"
    "C-c \""  "plot"))
#+END_SRC

*** Org Babel
#+BEGIN_SRC emacs-lisp :tangle no
(defun *org-babel-tangle-file-async (file &optional target-file lang-re finish-func)
  (require 'async)
  (async-start
   (apply-partially #'org-babel-tangle-file target-file lang-re)
   finish-func))
#+END_SRC

*** Org Indent
For some reason, ~show-smartparens-mode~ causes visual glitches.
#+BEGIN_SRC emacs-lisp
(add-hook 'org-indent-mode-hook #'turn-off-show-smartparens-mode)
#+END_SRC

The indicator doesn’t take the visual indentation into account.
#+BEGIN_SRC emacs-lisp
(when EMACS27+
  (add-hook 'org-mode-hook #'display-fill-column-indicator-mode--turn-off))
#+END_SRC

*** Org Keys
Bind shortcuts for navigating headings with the arrow keys.
Add ~org-babel-map~ to ~:localleader~.
#+BEGIN_SRC emacs-lisp
(map! :after org-keys
      :map org-mode-map
      "C-M-<left>"  #'org-up-element
      "C-M-<right>" #'org-down-element
      "C-M-<up>"    #'org-previous-visible-heading
      "C-M-<down>"  #'org-next-visible-heading
      (:localleader :prefix ("v" . "babel") "" org-babel-map))
#+END_SRC

*** Org Modules
These values have to be set before ~org-mode~ is loaded.
#+BEGIN_SRC emacs-lisp
(setq org-modules
      '(;; ol-w3m
        ;; ol-bbdb
        ol-bibtex
        ;; ol-docview
        ;; ol-gnus
        ol-info
        ;; ol-irc
        ;; ol-mhe
        ;; ol-rmail
        ;; ol-eww
        ))
#+END_SRC

*** Org Source
#+BEGIN_SRC emacs-lisp
(after! org-src
  (push! org-src-lang-modes
         '("dash" . sh)
         '("zsh"  . sh)))
#+END_SRC

** Projectile
#+BEGIN_SRC emacs-lisp
(map! :after projectile
      :map projectile-mode-map
      :leader :prefix "p"
      :desc "M-x in root" ":" #'projectile-run-command-in-root
      :desc "Shell command in root" "!" #'projectile-run-shell-command-in-root
      :desc "Async command in root" "&" #'projectile-run-async-shell-command-in-root)
#+END_SRC

** Smartparens
Activate ~show-smartparens-mode~ globally to highlight matching pairs.
#+BEGIN_SRC emacs-lisp
(after! smartparens (show-smartparens-global-mode +1))
#+END_SRC

Bind ~sp-raise-sexp~, which I use quite often.
#+BEGIN_SRC emacs-lisp
(map! :n "z r" #'sp-raise-sexp)
#+END_SRC

*** DONE Closing paren deleted twice ([[https://github.com/hlissner/doom-emacs/issues/3268][#3268]])
This is currently broken, in that two closing delimiters are deleted instead of
one. When the linked issue is resolved, this fix can be removed.
#+BEGIN_SRC emacs-lisp :tangle no
(setq sp-autodelete-pair nil)
#+END_SRC

** Which Key
Replace =<up>= and =<down>= with Unicode arrows.
#+BEGIN_SRC emacs-lisp
(after! which-key
  (push! which-key-replacement-alist
         '(("<up>"   . nil) . ("↑" . nil))
         '(("<down>" . nil) . ("↓" . nil))))
#+END_SRC

These are some default keybindings that are missing a description.
#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-x"      '("global" . "Global commands")
    "C-x RET"  "locale"
    "C-x ESC"  "complex-repeat"

    "C-x 4"    "other-window"
    "C-x 5"    "other-frame"
    "C-x 6"    "two-column"
    "C-x 8"    '("unicode" . "Unicode symbols")

    "C-x @"    '("apply-modifier" . "Add a modifier to the next event")
    "C-x a"    "abbrev"
    "C-x a i"  "inverse"
    "C-x n"    "narrow"
    "C-x r"    "rectangle/register"
    "C-x t"    "tab-bar"
    "C-x v"    "version-control"
    "C-x X"    "edebug"

    "C-c"      '("mode-specific" . "Mode specific commands")

    "M-s"      "search"
    "M-s h"    "highlight"
    "M-g"      "goto"))
#+END_SRC

** Yasnippet
In ~snippet-mode~, whitespace has significant meaning.
#+BEGIN_SRC emacs-lisp
(after! ws-butler
  (push 'snippet-mode ws-butler-global-exempt-modes))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-c &" "snippet"))
#+END_SRC

*** NOTE Other Packages
More Evil-related packages that I might try out some time.
+ [[https://github.com/willghatch/emacs-on-parens][on-parens]]
+ [[https://github.com/expez/evil-smartparens][evil-smartparens]]

* Languages
** Arduino
#+BEGIN_SRC emacs-lisp
(setq arduino-mode-home (expand-file-name "~/src/arduino/"))
#+END_SRC

This only works with a *patched* Arduino runtime.
#+BEGIN_SRC emacs-lisp
(when (sys-feature-p 'arduino/xdg)
  (let ((pref-file (expand-file-name "arduino/preferences.txt" XDG-DATA-HOME)))
    (when (file-readable-p pref-file)
      (setq ede-arduino-preferences-file pref-file))))
#+END_SRC

** Assembler
#+BEGIN_SRC emacs-lisp
(setq-hook! 'asm-mode-hook
  tab-width 8
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice! *asm--add-indentation-rules-a (&rest _)
  "Add rule clauses to `asm-calculate-indentation'."
  :before-until #'asm-calculate-indentation
  (and (looking-at "section") 0))
#+END_SRC

** BASIC
#+BEGIN_SRC emacs-lisp
(defvaralias 'basic-indent-offset 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'basic-mode-hook
  indent-level 4
  tab-width 4
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'basic-mode-hook
    +fmt-formatter #'basic-format-code))
#+END_SRC

** C/C++
#+BEGIN_SRC emacs-lisp
(defvaralias 'c-basic-offset 'indent-level)
#+END_SRC

*** TODO Code Style
The default is =doom=.
I have yet to create my own style.
#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl"
               '("linux"
                 (indent-tabs-mode . t)
                 (c-basic-offset   . 4)
                 (tab-width        . 4)))
  (setq c-default-style
        '((java-mode . "java")
          (awk-mode  . "awk")
          ;; (other     . "k&r")
          (other     . "jfl")
          )))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl" '("linux"
                       (indent-tabs-mode . t)
                       (tab-width . 4)
                       (c-basic-offset . 4)))
  (if (listp c-default-style)
      (setf (alist-get 'other c-default-style) "jfl")
    (setq c-default-style "jfl")))
#+END_SRC


*** C Mode
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (setq-hook! 'c-mode-hook
    flycheck-gcc-language-standard   "gnu18"
    flycheck-clang-language-standard "gnu18"))
#+END_SRC

*** C++ Mode
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (setq-hook! 'c++-mode-hook
    flycheck-gcc-language-standard   "gnu++17"
    flycheck-clang-language-standard "gnu++17"))
#+END_SRC

*** Meson Mode
Major mode for the [[https://mesonbuild.com][Meson Build System]].
#+BEGIN_SRC emacs-lisp
(use-package! meson-mode :defer t)
#+END_SRC

** Clojure :Lisp:
#+BEGIN_SRC emacs-lisp
(add-hook 'clojure-mode-hook #'lisp-mode-common-hook)
#+END_SRC

** Common Lisp :Lisp:
The file extension =.cl= is sometimes used.
#+BEGIN_SRC emacs-lisp
(push '("\\.cl\\'" . lisp-mode) auto-mode-alist)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'lisp-mode-hook #'lisp-mode-common-hook)
#+END_SRC

*** Sly
#+BEGIN_SRC emacs-lisp
(setq sly-default-lisp 'sbcl)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! sly
  (push! sly-lisp-implementations
         '(clisp ("clisp"))
         '(cmucl ("cmucl"))
         '(sbcl ("sbcl") :coding-system utf-8-unix)))
#+END_SRC

** Elixir
#+BEGIN_SRC emacs-lisp
(defvaralias 'elixir-basic-offset      'indent-level)
(defvaralias 'elixir-smie-indent-basic 'indent-level)
#+END_SRC

The Elixir formatter =mix format= sadly has very strong conventions. I might be
able to work around this when I implement my own =fmt-mix= functions, using
~doom/retab~ or =unexpand= after formatting, but for now we just set
~indent-level~ to =2=.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'elixir-mode-hook indent-level 2)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-popup-rule! "^\\*Alchemist-IEx\\*$"
  :size 0.3 :vslot 2 :ttl nil :quit 'current)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! alchemist
  (setq +eval-repls (assq-delete-all 'alchemist-mode +eval-repls)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :after alchemist
      :map alchemist-mode-map
      :localleader
      "a" 'alchemist-mode-keymap
      "i" #'alchemist-iex-run
      "I" #'alchemist-iex-project-run
      "M-r" #'alchemist-test-toggle-test-report-display)

(which-key-add-major-mode-key-based-replacements 'elixir-mode
  "C-c   a" "alchemist"
  "SPC m a" "alchemist"

  "C-c   a c" "compile"
  "C-c   a e" "execute"
  "C-c   a f" "info"
  "C-c   a h" "help"
  "C-c   a i" "iex"
  "C-c   a m" "mix"
  "C-c   a o" "macroexpand"
  "C-c   a X" "hex"
  "C-c   a p" "project"
  "C-c   a v" "eval"
  "SPC m a X" "hex"
  "SPC m a c" "compile"
  "SPC m a e" "execute"
  "SPC m a f" "info"
  "SPC m a h" "help"
  "SPC m a i" "iex"
  "SPC m a m" "mix"
  "SPC m a o" "macroexpand"
  "SPC m a p" "project"
  "SPC m a v" "eval")
#+END_SRC

** Emacs Lisp :Lisp:
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook       #'lisp-mode-common-hook)
(add-hook 'lisp-interaction-mode-hook #'lisp-mode-common-hook)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! elisp-mode
  (set-keymap-parent lisp-interaction-mode-map emacs-lisp-mode-map))
#+END_SRC

*** Evaluation
#+BEGIN_SRC emacs-lisp
(defun *eval/buffer-and-replace ()
  (interactive)
  (+eval/region-and-replace (point-min) (point-max))
  (let ((result (eval-buffer)))
    (kill-region (point-min) (point-max))
    (insert result)))

(defun *eval/sexp-and-replace ()
  (interactive)
  (let* ((beg (progn (backward-sexp 1) (point)))
         (end (progn (forward-sexp  1) (point))))
    (+eval/region-and-replace beg end)))

(map! :after elisp-mode
      :map emacs-lisp-mode-map
      :localleader :prefix "e"
      "B" #'*eval/buffer-and-replace
      "E" #'*eval/sexp-and-replace
      "R" #'+eval/region-and-replace)
#+END_SRC

*** Macro Expansion
#+BEGIN_SRC emacs-lisp
(defun *elisp-macroexpand-last-sexp ()
  (interactive)
  (when (and (bound-and-true-p evil-mode)
             (not evil-move-beyond-eol)
             (or (evil-normal-state-p) (evil-motion-state-p))
             (not (or (eobp) (eolp))))
    (forward-char))
  (backward-sexp)
  (emacs-lisp-macroexpand)
  (forward-sexp))

(map! :after elisp-mode
      :map emacs-lisp-mode-map
      :localleader
      "x" #'*elisp-macroexpand-last-sexp)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :after macrostep
      :map macrostep-keymap
      :n "c" #'macrostep-collapse)
#+END_SRC

** Fennel :Lisp:Lua:
#+BEGIN_SRC emacs-lisp
(add-hook 'fennel-mode-hook #'lisp-mode-common-hook)
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(setq-hook! 'haskell-mode-hook indent-level 2)
#+END_SRC

Doom Emacs uses this hook which seems not to exist.
#+BEGIN_SRC emacs-lisp
(add-hook! 'haskell-mode-hook
  (defun *haskell--run-mode-local-vars-hook ()
    (run-hooks 'haskell-mode-local-vars-hook)))
#+END_SRC

These bindings are used by many modes with an inferior REPL.
#+BEGIN_SRC emacs-lisp
(map! :after haskell-mode
      :map haskell-mode-map
      "C-c C-c" #'haskell-process-load-file
      "C-c C-k" #'haskell-process-load-file
      "C-c C-z" #'haskell-interactive-switch)
#+END_SRC

Flycheck raises a "Suspicious State" error when the linter exits with a nonzero
error code. Using =--no-exit-code= prevents this.
#+BEGIN_SRC emacs-lisp
(setq flycheck-hlint-args '("--no-exit-code"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! (dante flycheck)
  (flycheck-add-next-checker 'haskell-dante '(warning . haskell-hlint)))
#+END_SRC

** Hy :Lisp:Python:
#+BEGIN_SRC emacs-lisp
(add-hook 'hy-mode-hook #'lisp-mode-common-hook)
#+END_SRC

** JavaScript
#+BEGIN_SRC emacs-lisp
(defvaralias 'js-indent-level 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'js-mode-hook
  indent-level 2
  tab-width 2
  indent-tabs-mode t)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'js-mode-hook
    +fmt-formatter #'prettier-format-region))
#+END_SRC

** LaTeX
#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'latex-mode
    "C-c C-p"     '("preview" . "Inline formula preview")
    "C-c C-p C-c" "clear"
    "C-c C-o"     "fold"
    "C-c C-q"     "fill"
    "C-c C-t"     "toggle"))
#+END_SRC

Let Smartparens handle insertion of =$=.
#+BEGIN_SRC emacs-lisp
(map! :after tex-mode :map LaTeX-mode-map "$" nil)
#+END_SRC

Some Smartparens settings for LaTeX pairs.
Letting Smartparens handle these works best in my experience.
#+BEGIN_SRC emacs-lisp
(after! smartparens
  (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
    (sp-local-pair "\"`" "\"'"          ; German quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\"<" "\">"          ; French quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\\(" "\\)" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-local-pair "\\[" "\\]" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))))
#+END_SRC

Using =dvipng= is faster than =png= and is even recommended
in the [[info:preview-latex#Requirements][manual]] of =preview-latex=.
#+BEGIN_SRC emacs-lisp
(when (executable-find "dvipng") (setq preview-image-type 'dvipng))
#+END_SRC

*** NOTE Electric Env Pairs
Maybe add ~latex-electric-env-pair-mode~ to ~LaTeX-mode-hook~.

** Lisp
A common hook for all lisp modes.
#+BEGIN_SRC emacs-lisp
(defvar lisp-mode-common-hook nil
  "Hook called by all Lisp modes for common initialization.")

(defun lisp-mode-common-hook (&rest args)
  "Run all functions in `lisp-mode-common-hook' with ARGS."
  (apply #'run-hook-with-args 'lisp-mode-common-hook args))
#+END_SRC

Improve the comment insertion of ~comment-dwim~.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'lisp-mode-common-hook
  comment-start "; "
  comment-start-skip ";+\\s-*")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'lisp-mode-common-hook
    +fmt-formatter #'indent-region))
#+END_SRC

** Lua
Doom has already set a value for ~lua-indent-level~, so we have to unset it.
#+BEGIN_SRC emacs-lisp
(makunbound 'lua-indent-level)
(defvaralias 'lua-indent-level 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'lua-mode-hook
  indent-level 2
  tab-width 2
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'lua-mode-hook
    +fmt-formatter #'luaformatter-format-region))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq company-lua-interpreter 'lua53)
#+END_SRC

*** Indentation in Comments
Doom advises ~newline-and-indent~ to continue comments using the value of
~comment-line-break-function~. The standard value is ~comment-indent-new-line~,
which is broken in Lua's multiline comments.
#+BEGIN_SRC emacs-lisp
(defun *lua-comment-indent-new-line (&optional soft)
  "Break line at point and indent, continuing a series of line comments."
  (interactive)
  (if (or (not (lua-comment-or-string-p))
          (lua-string-p)
          (not (save-excursion
                 (goto-char (lua-comment-or-string-start-pos))
                 (looking-at-p "--\\[=*\\["))))
      (comment-indent-new-line soft)
    (delete-horizontal-space t)
    (newline nil t)
    (indent-according-to-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'lua-mode-hook
  comment-line-break-function #'*lua-comment-indent-new-line)
#+END_SRC

*** NOTE Comment deletion broken
The advice ~+default--delete-backward-char-a~ to ~backward-delete-char~ behaves
weirdly when deleting line comments inside of a multiline comment. I have not
yet found a fix for this.

** MoonScript :Lua:
Consolidate indentation.
#+BEGIN_SRC emacs-lisp
(defvaralias 'moonscript-indent-offset 'indent-level)
#+END_SRC

We are currently limited by ~moonscript-indent-line~, which doesn’t
respect ~indent-tabs-mode~.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'moonscript-mode-hook
  indent-level 2
  tab-width 8
  indent-tabs-mode nil)
#+END_SRC

Doom Emacs, annoyingly, sets ~moonscript-indent-offset~ to ~tab-width~ by default.
#+BEGIN_SRC emacs-lisp
(after! moonscript
  (remove-hook 'moonscript-mode-hook
               #'doom--setq-moonscript-indent-offset-for-moonscript-mode-h))
#+END_SRC

*** TODO Test this advice for indenting with tabs.
This might fix the issue with ~moonscript-indent-line~.
This should not be used with =Janfel/moonscript-mode=.
#+BEGIN_SRC emacs-lisp :tangle no
(defadvice! *moonscript--run-untabified-a (orig-fn &rest args)
  :around '(moonscript-indent-line moonscript-indent-level)
  (if (not indent-tabs-mode)
      (apply orig-fn args)
    (let (indent-tabs-mode)
      (untabify (line-beginning-position) (line-end-position))
      (apply orig-fn args)
      (tabify (line-beginning-position)
              (save-excursion (back-to-indentation) (point))))))
#+END_SRC

** Pascal
#+BEGIN_SRC emacs-lisp
(defvaralias 'pascal-indent-level  'indent-level)
(defvaralias 'pascal-case-indent   'indent-level)
(defvaralias 'opascal-indent-level 'indent-level)
(defvaralias 'opascal-case-indent  'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! '(pascal-mode-hook opascal-mode-hook)
  indent-level 3
  tab-width 3
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! '(pascal-mode-hook opascal-mode-hook)
    +fmt-formatter #'ptop-format-region))
#+END_SRC

We have to remove ~company-capf~ from ~company-backends~, because completion
would be unusable otherwise.
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion company)
  (setq-hook! '(pascal-mode-hook opascal-mode-hook)
    company-backends (remq 'company-capf company-backends)))
#+END_SRC

** Perl
#+BEGIN_SRC emacs-lisp
(defvaralias 'perl-indent-level  'indent-level)
(defvaralias 'cperl-indent-level 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! '(perl-mode-hook cperl-mode-hook)
  indent-level 4
  tab-width 4
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! '(perl-mode-hook cperl-mode-hook)
    +fmt-formatter #'perltidy-format-region))
#+END_SRC

** PHP
This allows me to not load the entire =:lang/php= module.
#+BEGIN_SRC emacs-lisp
(unless (featurep! :lang php) (use-package! php-mode :defer t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'php-mode-hook
  indent-level 4
  tab-width 4
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'php-mode-hook
    +fmt-formatter #'prettier-format-region))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(defvaralias 'python-indent-offset 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'python-mode-hook
  indent-level 4
  tab-width 4
  indent-tabs-mode nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'python-mode-hook
    +fmt-formatter #'black-format-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'python-mode
    "C-c C-p" "pipenv"
    "C-c C-t" "skeleton"))
#+END_SRC

*** Company Jedi
[[https://jedi.readthedocs.io/en/latest/][Jedi]] gives the best (non LSP) autocompletion for python.
[[https://github.com/syohex/emacs-company-jedi][=company-jedi=]] is a backend for =company= that interfaces with Jedi.
This adds =company-jedi= to =company-backends= in Python buffers.
The package will load when =company-jedi= is invoked by =company=.
#+BEGIN_SRC emacs-lisp
(use-package! company-jedi
  :when (featurep! :completion company)
  :after company
  :commands company-jedi
  :init (set-company-backend! 'python-mode 'company-jedi))
#+END_SRC

*** _Backup
:PROPERTIES:
:header-args+: :tangle no :noweb-ref :noweb no-export
:END:
Use system =mspyls= for =lsp-python-ms=.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :lang python +lsp)
  (after! lsp-python-ms
    (setq lsp-python-ms-dir "/usr/lib/microsoft-python-language-server"
          lsp-python-ms-executable "/usr/bin/mspyls")))
#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp
(defvaralias 'rustic-indent-offset 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! '(rustic-mode-hook rustic-macro-expansion-mode-hook)
  indent-level 4
  tab-width 4
  indent-tabs-mode t)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! '(rustic-mode-hook rustic-macro-expansion-mode-hook)
    +fmt-formatter #'rustic-format-buffer))
#+END_SRC

The [[https://github.com/rust-analyzer/rust-analyzer][rust-analyzer]] is an experimental language server and is to become
the successor to RLS.
#+BEGIN_SRC emacs-lisp
(when (executable-find "rust-analyzer")
  (setq rustic-lsp-server 'rust-analyzer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice! *rustic--rustfmt-respect-indent-tabs-mode-a (orig-fn &rest args)
  "Make `rustic-format-buffer' respect `indent-tabs-mode'."
  :around #'rustic-format-buffer
  (let ((rustic-rustfmt-config-alist
         (cons (cons 'hard_tabs indent-tabs-mode)
               rustic-rustfmt-config-alist)))
    (apply orig-fn args)))
#+END_SRC

Make ~lsp-rust~ respect the =CARGO_HOME= and =RUSTUP_HOME= environment
variables.
#+BEGIN_SRC emacs-lisp
(defconst CARGO-HOME
  (-> (getenv "CARGO_HOME")
      (string-or "~/.cargo/")
      (file-name-as-directory)
      (expand-file-name)))

(defconst RUSTUP-HOME
  (-> (getenv "RUSTUP_HOME")
      (string-or "~/.rustup/")
      (file-name-as-directory)
      (expand-file-name)))

(setq lsp-rust-library-directories
      (list (expand-file-name "registry/src/" CARGO-HOME)
            (expand-file-name "toolchains/" RUSTUP-HOME)))
#+END_SRC

** Scheme :Lisp:
#+BEGIN_SRC emacs-lisp
(add-hook 'scheme-mode-hook #'lisp-mode-common-hook)
#+END_SRC

*** Geiser
Make =geiser= read init files from ~doom-private-dir~ instead of ~$HOME~.
#+BEGIN_SRC emacs-lisp
(let ((config-dir (expand-file-name "geiser/" doom-private-dir)))
  (cl-dolist (s '(guile chez chicken racket))
    (set (intern (format "geiser-%s-init-file" s))
         (expand-file-name (format "init-%s.scm" s) config-dir))))
#+END_SRC

On Arch, the [[https://www.call-cc.org/][Chicken Scheme]] binaries are called =chicken-csi= and =chicken-csc=.
#+BEGIN_SRC emacs-lisp
(when (executable-find "chicken-csi")
  (setq geiser-chicken-binary "chicken-csi"))
#+END_SRC

** Shell
#+BEGIN_SRC emacs-lisp
(defvaralias 'sh-basic-offset 'indent-level)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq-hook! 'sh-mode-hook
  indent-level 4
  tab-width 4
  indent-tabs-mode t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'sh-mode-hook
    +fmt-formatter #'shfmt-format-region))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(set-file-template! "\\.sh\\'"
  :trigger "__sh"
  :mode 'sh-mode)
#+END_SRC

** XML
#+BEGIN_SRC emacs-lisp
(setq-hook! 'nxml-mode-hook
  indent-level 2
  tab-width 8
  indent-tabs-mode nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'nxml-mode-hook
    +fmt-formatter #'tidy-format-region))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defadvice! *nxml--parameter-soft-not-being-optional-a (&optional soft)
  "Make the parameter SOFT optional to follow the spec of `comment-line-break-function'."
  :filter-args #'nxml-newline-and-indent
  (list soft))
#+END_SRC

Make the indentation inside of comments respect ~nxml-child-indent~.
#+BEGIN_SRC emacs-lisp
(defadvice! *nxml--indent-correctly-inside-comments-a
  (orig-fn pos open-delim close-delim)
  :around #'nxml-compute-indent-in-delimited-token
  (let ((indent (funcall orig-fn pos open-delim close-delim)))
    (when (and (string= "<!--" open-delim) (string= "-->" close-delim)
               (progn (goto-char xmltok-start) (looking-at-p "<!--[[:blank:]]*$"))
               (progn (goto-char pos)
                      (back-to-indentation)
                      (not (looking-at-p "-->"))))
      (goto-char xmltok-start)
      (setq indent (+ (current-column) nxml-child-indent)))
    indent))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! nxml-mode
  (modify-syntax-entry ?\" "\"" nxml-mode-syntax-table)
  (modify-syntax-entry ?<  "(>" nxml-mode-syntax-table)
  (modify-syntax-entry ?>  ")<" nxml-mode-syntax-table))
#+END_SRC

Disable ~smartparens-mode~ because it it kind of useless in ~nxml-mode~.
#+BEGIN_SRC emacs-lisp
(add-hook 'nxml-mode-hook #'turn-off-smartparens-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (sp-with-modes '(nxml-mode)
    (sp-local-pair "<" ">" :actions nil)
    (sp-local-pair "'" "'" :actions nil)
    (sp-local-pair "\"" "\"" :unless '(:rem sp-point-after-word-p))))
#+END_SRC

Replace the original ~nxml-mode~ rules with ones that aren’t broken.
#+BEGIN_SRC emacs-lisp
(after! hideshow
  (assq-delete-all 'nxml-mode hs-special-modes-alist)
  (push! hs-special-modes-alist
         '(nxml-mode
           "<!--\\|<[^/>?][^>]*[^/]>"
           "-->\\|</[^>]*[^/]>"
           "<!--"
           sgml-skip-tag-forward
           nil)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq lsp-xml-server-work-dir (expand-file-name "lsp4xml/" XDG-CACHE-HOME))
#+END_SRC

* Keybindings
** Ä/Ö/Ü
#+BEGIN_SRC emacs-lisp
(map! "C-ü" #'execute-extended-command)
(map! :map key-translation-map
      "C-ö" (kbd "C-x")
      "C-ä" (kbd "C-c"))
#+END_SRC

** Copy/Paste
Use C-p to paste.
#+BEGIN_SRC emacs-lisp
(map! :i "C-p" #'yank
      :i "M-p" #'yank-pop)
#+END_SRC

** Folding
Completely remap the ~+fold~ commands, making use of =h= as a prefix.
This frees up =z r= =z m=.
#+BEGIN_SRC emacs-lisp
(map! :when (and (featurep! :editor evil)
                 (featurep! :editor fold))
      :n "z O" #'+fold/open-all
      :n "z C" #'+fold/close-all

      :mn "h" nil
      :n "h h" #'+fold/toggle
      :n "h t" #'+fold/toggle
      :n "h a" #'+fold/toggle
      :n "h o" #'+fold/open
      :n "h O" #'+fold/open-all
      :n "h c" #'+fold/close
      :n "h C" #'+fold/close-all
      :m "h n" #'+fold/next
      :m "h p" #'+fold/previous)
#+END_SRC

** Leader Extensions
It is handy to have ~negative-argument~ on a binding
similar to that of ~universal-argument~.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Negative Argument" "-" #'negative-argument)
#+END_SRC

Bind ~shell-command~ in a similar way to =M-x= and =M-;=.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Shell command" "!" #'shell-command
      :desc "Async command" "&" #'async-shell-command)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "b"
      :desc "Rename buffer" "R" #'rename-buffer)
#+END_SRC

Bind ~indent-region~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "c"
      :desc "Indent buffer/region" "i" #'indent-region
      ;; We need to move this out of the way.
      (:when (featurep! :tools lsp)
       :desc "LSP Organize imports" "I" #'lsp-organize-imports))
#+END_SRC

Bind mnemonics for =git add=.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "g"
      (:when (featurep! :ui vc-gutter)
       :desc "Git add hunk" "a" #'git-gutter:stage-hunk
       :desc "Diff hunk"    "d" #'git-gutter:popup-hunk)
      (:when (featurep! :tools magit)
       :desc "Git add file" "A" #'magit-stage-file))
#+END_SRC

Bind ~auto-fill-mode~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "t"
      :desc "Hard line wrapping" "W" #'auto-fill-mode)
#+END_SRC

** _Backup
:PROPERTIES:
:header-args+: :tangle no
:END:
Some stuff I don't use anymore.
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "List buffers" "b L" #'list-buffers)
(map! "<mouse-8>" #'backward-page
      "<mouse-9>" #'forward-page)
(map! :m "C-e" nil)
#+END_SRC
