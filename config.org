#+TITLE: Doom Emacs Configuration
#+AUTHOR: Jan Felix Langenbach
#+EMAIL: o.hase3@gmail.com
#+DESCRIPTION: Doom Emacs configuration of Jan Felix Langenbach
#+LANGUAGE: en
#+STARTUP: fold
#+PROPERTY: header-args            :results silent
#+PROPERTY: header-args:emacs-lisp :tangle yes :lexical yes

* Introduction
These are some useful links to manuals and other peoples configs.

+ [[https://www.gnu.org/software/emacs/manual][Emacs Manual]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/elisp/][Emacs Lisp Manual]]
+ [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]]
+ [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
+ [[https://github.com/MatthewZMD/.emacs.d][M-Emacs]]
+ [[github:Townk/doom-emacs-private][Townk’s Config]]
+ [[https://github.com/poncie/.emacs.d][Poncie’s Config]]
+ [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua’s Config]]
+ [[http://aaronbedra.com/emacs.d][Aaron Bedra’s Config]]
+ [[https://github.com/KaratasFurkan/.emacs.d][Furkan Karataş’s Config]]

** Startup
This header comment ensures that everything in this file is lexically scoped.
#+begin_src emacs-lisp
;;; config.el -*- lexical-binding: t; -*-
#+end_src

Acquire focus when creating a new frame.
#+begin_src emacs-lisp
(add-hook! 'window-setup-hook (x-focus-frame nil))
#+end_src

Require [[https://github.com/magnars/dash.el][dash.el]], a modern list library inspired by Clojure. Not currently used.
#+begin_src emacs-lisp :tangle no
(require 'dash)
#+end_src

* Definitions
** Functions and Macros
#+begin_src emacs-lisp
(defmacro async! (&rest body)
  "Evaluate BODY asynchronously for side-effects only."
  (declare (indent 1))
  `(async-start (lambda () ,@body) #'ignore))
#+end_src

#+begin_src emacs-lisp
(defun directory-name-base (dirname)
  "Return the last component of DIRNAME."
  (declare (pure t) (side-effect-free t))
  (file-name-as-directory (file-name-nondirectory (directory-file-name dirname))))
#+end_src

#+begin_src emacs-lisp
(defun *evil-blocky-state-p ()
  "Return non-nil if `evil-state' is `normal', `motion' or `visual'."
  (declare (side-effect-free t))
  (and (boundp 'evil-state) (memq evil-state '(normal motion visual))))
#+end_src

#+begin_src emacs-lisp
(defun flatten-one (list)
  "Flatten one level of LIST."
  (declare (pure t) (side-effect-free t))
  (apply #'append (mapcar #'doom-enlist list)))
#+end_src

This macro returns the status of ~lexical-binding~ at the callsite.
#+begin_src emacs-lisp
(defmacro lexical-binding-enabled-p ()
  "Return t if lexical binding is in effect."
  (let ((funcsym (make-symbol "func")) (varsym (make-symbol "var")))
    `(let (,funcsym ,varsym)
       (let ((,varsym t))
         (setq ,funcsym (lambda () ,varsym)))
       (funcall ,funcsym))))
#+end_src

This snippet can be used to test the status of ~lexical-binding~ during
~org-mode~ source block evaluation. To test this, add =:lexical yes= or
=:lexical no= to the =begin_src= line.
#+begin_src emacs-lisp :tangle no
(if (lexical-binding-enabled-p) "Yes" "No")
#+end_src

#+begin_src emacs-lisp
(defmacro measure-time (&rest body)
  "Measure the time it takes to evaluate BODY."
  `(let ((time (current-time)))
     ,@body
     (message "%.06f" (float-time (time-since time)))))
#+end_src

#+begin_src emacs-lisp
(defun string-or (&rest strings)
  "Return the first non-nil and non-empty string in STRINGS."
  (declare (pure t) (side-effect-free t))
  (cl-dolist (s strings)
    (when (and s (not (string-empty-p s)))
      (cl-return s))))
#+end_src

#+begin_src emacs-lisp
(defun sys-feature-p (feature)
  "Return t if FEATURE is available on this system."
  (declare (side-effect-free t))
  (memq feature SYS-FEATURES))
#+end_src

#+begin_src emacs-lisp
(defmacro push! (place &rest values)
  "Push VALUES into PLACE."
  `(setf ,place (nconc (list ,@values) ,place)))
#+end_src

** Commands
#+begin_src emacs-lisp
(defun indent-buffer-or-region (&optional arg)
  (interactive "P")
  (if (doom-region-active-p)
      (indent-region (doom-region-beginning) (doom-region-end) arg)
    (indent-region (point-min) (point-max) arg)))

(map! :leader :prefix "c"
      :desc "Indent buffer/region" "i" #'indent-buffer-or-region
      ;; We need to move this out of the way.
      (:when (featurep! :tools lsp)
       :desc "LSP Organize imports" "I" #'lsp-organize-imports))
#+end_src

#+begin_src emacs-lisp
(defun move-comment-to-column (&optional column)
  "Move any end-of-line comments to COLUMN or `comment-column'.
Modifies the match data; use `save-match-data' if necessary."
  (interactive "*")
  (let ((beg (if (doom-region-active-p)
                 (doom-region-beginning)
               (line-beginning-position)))
        (end (if (doom-region-active-p)
                 (doom-region-end)
               (line-end-position)))
        (column (or column comment-column))
        (indent-tabs-mode nil))
    (save-excursion
      (goto-char beg)
      (while (< (point) end)
        (beginning-of-line)
        (when (looking-at ".*\\s-\\(\\s<\\)")
          ;; Go to the last comment starter preceded by whitespace.
          (goto-char (match-beginning 1))
          (let ((old-column (current-column)))
           ;; Delete all whitespace before point.
           (delete-char (abs (skip-syntax-backward "\\s-")))
           ;; Indent and adjust `end' accordingly.
           (cl-incf end (- (indent-to column 1) old-column))))
        (forward-line 1)))))

(map! :n "g C" #'move-comment-to-column)
#+end_src

[[https://lists.gnu.org/archive/html/emacs-devel/2020-07/msg00326.html][Stolen from Jeff Norden on the =emacs-devel= mailing list.]]
#+begin_src emacs-lisp
(defun keyboard-quit-strong ()
  (interactive)
  (if (not (eq last-command 'keyboard-quit-strong))
      (keyboard-quit)
    (setq this-command 'top-level)
    (ding)
    (top-level)))

(map! "C-M-g" #'keyboard-quit-strong)
#+end_src

** Constants
*** System
I redefine the operating system constants of Doom Emacs to give them docstrings.
#+begin_src emacs-lisp
(defconst IS-LINUX IS-LINUX
  "Are we on a Linux system?")

(defconst IS-MAC IS-MAC
  "Are we on a Mac?")

(defconst IS-WINDOWS IS-WINDOWS
  "Are we on a Windows system?")

(defconst IS-BSD IS-BSD
  "Are we on a BSD system?")
#+end_src

*** Environment
These constants allow me to use the correct directories everywhere,
without lengthy invocation of =getenv=.
#+begin_src emacs-lisp
(defconst XDG-DATA-HOME
  (thread-first (getenv "XDG_DATA_HOME")
    (string-or "~/.local/share/")
    (file-name-as-directory)
    (expand-file-name))
  "The value of $XDG_DATA_HOME where programs store data.")

(defconst XDG-CONFIG-HOME
  (thread-first (getenv "XDG_CONFIG_HOME")
    (string-or "~/.config/")
    (file-name-as-directory)
    (expand-file-name))
  "The value of $XDG_CONFIG_HOME where programs place configuration files.")

(defconst XDG-CACHE-HOME
  (thread-first (getenv "XDG_CACHE_HOME")
    (string-or "~/.cache/")
    (file-name-as-directory)
    (expand-file-name))
  "The value of $XDG_CACHE_HOME where programs place cache files.")

(defconst SYS-FEATURES
  (mapcar #'intern (split-string (or (getenv "SYS_FEATURES") "") ":" t))
  "A list of symbols which represent system features.")
#+end_src

** Redefinitions
Rebind some =dash.el= symbols to use native Emacs functions.
#+begin_src emacs-lisp
(after! dash
  (defalias '->    #'thread-first)
  (defalias '->>   #'thread-last)
  (defalias '-map  #'mapcar)
  (defalias '-some #'seq-some)
  (defalias '-all? #'seq-every-p)
  (when EMACS27+ (defalias '-flatten #'flatten-tree)))
#+end_src

* General Configuration
** Appearance
Increase line spacing to make the text more legible. [[https://lists.gnu.org/archive/html/emacs-devel/2021-05/msg00180.html][This message]] on the
emacs-devel mailing list compares several values for this variable.
#+begin_src emacs-lisp
(setq-default line-spacing 0.10)
#+end_src

Make the block cursor stretch to highlight tab characters.
#+begin_src emacs-lisp
(setq-default x-stretch-cursor t)
#+end_src

*** Fonts
Doom exposes six (optional) variables for controlling fonts in Doom. Here
are the three important ones:

+ ~doom-font~
+ ~doom-variable-pitch-font~
+ ~doom-big-font~ -- used for ~doom-big-font-mode~; use this for
  presentations or streaming.

They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
font string. You generally only need to specify ~doom-font~ and
~doom-variable-pitch-font~.
#+begin_src emacs-lisp :tangle no
;; Example
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_src

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Source Code Pro" :size 13)
      doom-serif-font (font-spec :family "Source Serif Pro")
      doom-variable-pitch-font (font-spec :family "Source Sans Pro"))
#+end_src

*** Theme
Doom provides a selection of themes from the [[github:hlissner/emacs-doom-themes][=doom-themes=]] repo.
#+begin_src emacs-lisp
(setq doom-theme
      (cl-case SYSTEM
        ('Phantom 'doom-one)
        ('Tesla   'doom-one-light)
        (t        'doom-one)))
#+end_src

** Behavior
Don’t untabify when deleting a tab character.
#+begin_src emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+end_src

Move files to trash instead of deleting them.
#+begin_src emacs-lisp
(setq delete-by-moving-to-trash t)
#+end_src

** Custom.el
Move the ~customize~ blocks into =custom.el=.
#+begin_src emacs-lisp
(setq custom-file (expand-file-name "custom.el" doom-private-dir))
#+end_src

** Dashboard
Enable Henrik Lissners =doom-dashboard= splash image.
#+begin_src emacs-lisp
(setq fancy-splash-image (concat doom-private-dir "splash.png"))
#+end_src

** Dead Keys
:PROPERTIES:
:header-args:emacs-lisp+: :tangle no
:END:
This is a workaround for when composing using IBus doesn’t work.
This bug is triggered by not having =ttf-bitstream-vera= installed.
#+begin_src emacs-lisp
(defconst XIM-INPUT-BROKEN nil
  "If this is t, the input of special characters using XIM is broken.")
#+end_src

#+begin_src emacs-lisp
(when XIM-INPUT-BROKEN
  (add-hook! 'doom-first-input-hook (require 'iso-transl))
  (after! iso-transl
    (cl-dolist (keypair iso-transl-dead-key-alist)
      (define-key key-translation-map
        (vector (cdr keypair) (cdr keypair)) (string (car keypair))))))
#+end_src

** Emacs C Source Code
#+begin_src emacs-lisp
(defvar source-directory-base
  (directory-name-base source-directory)
  "Name of `source-directory' without the leading path.

This variable is a string of the form “emacs-VERSION/” where VERSION is
the true version of Emacs including any release-candidate specifiers.")
#+end_src

#+begin_src emacs-lisp
(setq find-function-C-source-directory
      (seq-some
       (lambda (x) (let ((dir (expand-file-name "src/" x)))
                     (when (file-readable-p (concat dir "emacs.c")) dir)))
       (nconc
        (list (expand-file-name "../src/emacs/" invocation-directory))
        (when (or IS-BSD IS-LINUX IS-MAC)
          (list (expand-file-name (directory-name-base source-directory) "/usr/local/src/")
                (expand-file-name (format "emacs-%s" emacs-version)      "/usr/local/src/")))
        (list source-directory))))
#+end_src

** HL Line Mode
While ~hl-line-mode~ is active, ~face-at-point~ always returns ~hl-line~.
This advice unhighlights the current line before ~face-at-point~ is called.
#+begin_src emacs-lisp
(after! hl-line
  (defadvice! *hl-line--fix-face-at-point-a (&rest _)
    :before '(describe-char face-at-point)
    (when hl-line-mode
      (hl-line-unhighlight))))
#+end_src

** Keyboard Input

*** Fixes for =feature/pgtk= :28:
Deactivate the Hyper modifier on =pgtk=, =pgtk= interprets =mod3= as Hyper,
which is the same modifier that Neo uses for =ISO_Level5_Shift= aka =Mod4=.
The fix is taken from [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2021-05/msg00752.html][this mail]] on =bug-gnu-emacs=.
#+begin_src emacs-lisp
(when (and EMACS28+ (eq window-system 'pgtk))
  (put 'none 'modifier-value 0)
  (setq x-hyper-keysym 'none))
#+end_src

** Mouse Behavior
Doom changes these in a way I don’t like. Set them back to the default values.
#+begin_src emacs-lisp
(setq mouse-wheel-scroll-amount
      '(5 ((shift) . 1) ((control) . text-scale) ((meta) . nil)))
(setq mouse-wheel-progressive-speed nil)
#+end_src

** Native Compilation :28:
#+begin_src emacs-lisp
(setq native-comp-deferred-compilation t)
(setq native-comp-async-report-warnings-errors nil)
#+end_src

* Editor Features
** Automatic Formatting and Indentation
*** Custom Formatting Engine
I replace the default formatting function with my own.
#+begin_src emacs-lisp
(map! :when (featurep! :editor fmt)
      :nv "g =" #'+fmt:region
      :map doom-leader-code-map
      :desc "Format buffer/region" "f" #'+fmt/dwim)
#+end_src

*** Indent using Tabs
Disable tab insertion by default. It will be enabled manually for each mode.
#+begin_src emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

These functions have a tendency to insert tabs where they don’t belong.
#+begin_src emacs-lisp
(defadvice! *emacs--disable-indent-tabs-mode-a (orig-fn &rest args)
  "Let `indent-tabs-mode' be bound to nil."
  :around '(align-areas comment-indent indent-relative)
  (let (indent-tabs-mode) (apply orig-fn args)))
#+end_src

*** Indent Guides
The package [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]] draws a line for each indentation level.
This should however not be the default, as it is rather resource heavy.
#+begin_src emacs-lisp
(remove-hook! '(prog-mode-hook text-mode-hook conf-mode-hook)
  #'highlight-indent-guides-mode)
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! highlight-indent-guides
  ;; Maybe change this to mode-by-mode basis.
  :commands (highlight-indent-guides-mode)
  :config
  ;; Use bitmap images instead of characters.
  (setq highlight-indent-guides-method 'bitmap)
  ;; Use a bitmap of a solid line.
  (setq highlight-indent-guides-bitmap-function
        #'highlight-indent-guides--bitmap-line)
  ;; Highlight the nearest indent guide.
  (setq highlight-indent-guides-responsive 'top))
#+end_src

** Code Folding
*** Folding Module
Completely remap the ~+fold~ commands, making use of =h= as a prefix.
This frees up =z r= =z m=.
#+begin_src emacs-lisp
(map! :when (featurep! :editor fold)
      :n "z O" #'+fold/open-all
      :n "z C" #'+fold/close-all

      :mn "h" nil
      :n "h h" #'+fold/toggle
      :n "h t" #'+fold/toggle
      :n "h a" #'+fold/toggle
      :n "h o" #'+fold/open
      :n "h O" #'+fold/open-all
      :n "h c" #'+fold/close
      :n "h C" #'+fold/close-all
      :m "h n" #'+fold/next
      :m "h p" #'+fold/previous)
#+end_src

*** Org Mode
#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :n "h h" #'+org/toggle-fold
      :n "h t" #'+org/toggle-fold
      :n "h a" #'+org/toggle-fold
      :n "h o" #'+org/open-fold
      :n "h O" #'+org/open-all-folds
      :n "h c" #'+org/close-fold
      :n "h C" #'+org/close-all-folds
      :m "h n" #'+org/show-next-fold-level
      :m "h p" #'+org/hide-next-fold-level
      :m "h s" #'org-show-subtree)
#+end_src

*** Hide/Show Mode
#+begin_src emacs-lisp
(map! :after hideshow
      :map hs-minor-mode-map
      :leader :prefix ("c h" . "Hide code")
      :desc "Toggle hiding"    "h" #'hs-toggle-hiding
      :desc "Hide all"         "a" #'hs-hide-all
      :desc "Show all"         "A" #'hs-show-all
      :desc "Hide block"       "b" #'hs-hide-block
      :desc "Show block"       "B" #'hs-show-block
      :desc "Hide level"       "l" #'hs-hide-level
      :desc "Hide top comment" "c" #'hs-hide-initial-comment-block)
#+end_src

** Electric Quotes
I have implemented ~set-electric-quote-chars~ in [[file:autoload/electric-quote.el][=autoload/electric-quote.el=]].

*** NOTE Emacs 27 adds ~electric-quote-replace-double~
This variable might be very useful in certain modes.

** File Templates
#+begin_src emacs-lisp :tangle no
(when (featurep! :editor file-templates)
  (defvar +file-templates-fallback-dir +file-templates-dir
    "The directory where the file templates provided by Doom are stored.")

  (setq +file-templates-dir (expand-file-name "templates/" doom-private-dir))

  (after! yasnippet
    (setq yas-snippet-dirs
          (nconc (when (featurep! :editor snippets) '(+snippets-dir))
                 '(+file-templates-dir)
                 (thread-last yas-snippet-dirs
                   (delq '+snippets-dir)
                   (delq '+file-templates-dir))
                 '(+file-templates-fallback-dir)))))
#+end_src

** Fill Column Indicator :27:
#+begin_src emacs-lisp
(when EMACS27+
  ;; Customize `global-display-fill-column-indicator-modes' to disable
  ;; `display-fill-column-indicator-mode' in certain modes.
  (global-display-fill-column-indicator-mode +1))
#+end_src

** Form Feed
This mode displays instances of =^L= (form feed) as horizontal lines.
#+begin_src emacs-lisp
(use-package! form-feed
  :hook ((prog-mode text-mode) . form-feed-mode))
#+end_src

*** Keybindings
Allows jumping from =^L= to =^L=.
#+begin_src emacs-lisp
(map! "C-M-<next>"  #'forward-page
      "C-M-<prior>" #'backward-page)
#+end_src

** Help Buffers
Some help texts and function definitions contain tab character that are assumed
to be eight spaces wide.
#+begin_src emacs-lisp
(setq-hook! '(help-mode-hook helpful-mode-hook)
  tab-width 8
  x-stretch-cursor nil)
#+end_src

** LSP
*** Code Lens
Enable code lenses, which are those “Run | Debug” buttons that appear over
function definitions.
#+begin_src emacs-lisp
(setq lsp-lens-enable t)
#+end_src

For some reason, Doom hooks ~ccls-code-lens-mode~ onto ~lsp-lens-mode-hook~,
causing a second “Run | Debug” button to appear. Until I know why this is done,
it is easiest to just remove this hook.
#+begin_src emacs-lisp
(remove-hook 'lsp-lens-mode-hook #'ccls-code-lens-mode)
#+end_src

*** TODO Try semantic highlighting.
#+begin_src emacs-lisp :tangle no
(setq lsp-enable-semantic-highlighting t)
#+end_src

** Line Numbers
On =Tesla=, ~display-line-numbers-mode~ causes noticeable slowdown.
#+begin_src emacs-lisp
(when (eq SYSTEM 'Tesla)
  (remove-hook!
    '(prog-mode-hook
      text-mode-hook
      conf-mode-hook)
    #'display-line-numbers-mode))
#+end_src

** Minibuffer :28:
Enable ~cua-mode~ the minibuffer to give a more seamless editing experience.
Sadly, this enables ~cua-mode~ everywhere, so we can not do this.
#+begin_src emacs-lisp :tangle no
(add-hook 'minibuffer-setup-hook #'cua-mode)
#+end_src

** Online Lookup
Add more online search providers.
#+begin_src emacs-lisp
(when (featurep! :tools lookup)
  (push! +lookup-provider-url-alist
         '("CPP Reference" "https://cppreference.com/w/?search=%s")))
#+end_src

** Shell Commands
Make the output buffers of ~shell-command~ and ~async-shell-command~ be popups.
Needs ~EMACS28+~ for ~shell-command-buffer-name~
#+begin_src emacs-lisp
(when EMACS28+
  (set-popup-rule!
    (rx line-start
        (or (literal shell-command-buffer-name)
            (literal shell-command-buffer-name-async))
        line-end)
    :quit t))
#+end_src

** Spell Checking
*** Ispell
#+begin_src emacs-lisp
(setq ispell-dictionary "en"
      ispell-extra-args
      '("--sug-mode=ultra"
        "--run-together"
        "--dont-tex-check-comments"))
#+end_src

#+begin_src emacs-lisp
(after! ispell
  (pushnew! ispell-skip-region-alist
            '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:")
            '("#\\+BEGIN_SRC"     . "#\\+END_SRC")
            '("#\\+begin_src"     . "#\\+end_src")
            '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE")
            '("#\\+begin_example" . "#\\+end_example")))
#+end_src

#+begin_src emacs-lisp
(unless (featurep! :checkers spell)
  (add-hook! 'text-mode-hook
    (defun *ispell--remove-run-together-switch-for-aspell-h ()
      (setq-local ispell-extra-args (remove "--run-together" ispell-extra-args)))))
#+end_src

*** Flyspell
The new =+everywhere= flag has made this unnecessary.
#+begin_src emacs-lisp :tangle no
(when (featurep! :checkers spell +flyspell)
  (remove-hook 'prog-mode-hook #'flyspell-mode))
#+end_src

*** Spell Fu
#+begin_src emacs-lisp
(when (and (featurep! :checkers spell)
           (not (featurep! :checkers spell +flyspell)))
  (after! spell-fu
    (push 'org-document-info (alist-get 'org-mode +spell-excluded-faces-alist))))
#+end_src

** Tab Bar :27:
For ~tab-line~ configuration, steal from [[https://gitlab.com/andreyorst/dotfiles/-/blob/master/.config/emacs/init.el][andreyorst]].

Wrap everything in a conditional. Disabled because WIP.
#+begin_src emacs-lisp :tangle no
(when EMACS27+
  (after! tab-bar))
#+end_src

#+begin_src emacs-lisp :tangle no
(setq tab-bar-close-button-show t
      tab-bar-new-button-show t
      tab-bar-separator nil
      tab-bar-tab-name-ellipsis "…"
      tab-bar-tab-name-truncated-max 20
      tab-bar-tab-name-function #'tab-bar-tab-name-truncated
      tab-bar-close-button (propertize
                            (if (char-displayable-p ?×) " × " " x ")
                            'close-tab t
                            :help "Click to close tab"))
#+end_src

#+begin_src emacs-lisp :tangle no
(let ((fg   (face-attribute 'default   :foreground))
      (bg   (face-attribute 'default   :background))
      (base (face-attribute 'mode-line :background)))
  (set-face-attribute
   'tab-bar nil
   :foreground fg
   :background bg
   :box (list :line-width -1 :color base))
  (set-face-attribute
   'tab-bar-tab nil
   :foreground fg
   :background bg
   :box (list :color bg)
   )
  (set-face-attribute
   'tab-bar-tab-inactive nil
   :foreground fg
   :background base
   :box (list :color base)))
#+end_src

** Terminal
*** Shell
*** EShell
*** Term
*** VTerm
Normal state does not make sense in a terminal buffer.
#+begin_src emacs-lisp
(set-evil-initial-state! 'vterm-mode 'insert)
#+end_src

Disable =fill-column-indicator=. It is useless in a terminal window.
#+begin_src emacs-lisp
(add-hook! 'vterm-mode-hook (display-fill-column-indicator-mode -1))
#+end_src

This removes the problematic default popup rule for =vterm= buffers and replaces
it with a sane alternative.
#+begin_src emacs-lisp
(after! vterm
  (setq display-buffer-alist (assoc-delete-all "^\\*vterm" display-buffer-alist))
  (set-popup-rule! "^\\*doom:vterm-popup:" :size 0.25 :vslot -4 :select t :quit 'current :ttl nil))
#+end_src

Previously, VTerm used ~last-input-event~ instead of ~last-command-event~,
which does not handle keys translated using ~key-translation-map~ correctly.
This includes all keys on the keypad. Resolved since [[github:akermu/emacs-libvterm/pull/494][PR #494]].

** Todo Keywords
#+begin_src emacs-lisp
(after! hl-todo
  (push! hl-todo-keyword-faces
         '("CONF" success bold)
         '("MAYBE" font-lock-keyword-face bold)
         '("WIP" font-lock-constant-face bold)))
#+end_src

** Tree View
*** Neotree
#+begin_src emacs-lisp
(map! :when (featurep! :ui neotree)
      :after neotree
      :map neotree-mode-map
      :n "<tab>" #'neotree-quick-look)
#+end_src

*** Treemacs
#+begin_src emacs-lisp
(map! :when (and (featurep! :ui treemacs) (featurep! :editor evil))
      :after treemacs-evil
      :map evil-treemacs-state-map
      "p" #'treemacs-peek)
#+end_src

** Undo/Redo
*** Undo Fu
*** Undo Tree
When =undo-tree= is allowed to automatically save the undo history, it somehow
chokes on an empty undo list and interrupts us with constant errors.
#+begin_src emacs-lisp
(setq undo-tree-auto-save-history nil)
#+end_src

*** Keybindings
Bind keys for ~redo~.
#+begin_src emacs-lisp
(map! "<redo>" #'redo
      :n "U" #'redo)
#+end_src

** Universal Argument
#+begin_src emacs-lisp
(map! :map universal-argument-map "<kp-add>" #'universal-argument-more)
(map! :m "<kp-add>"      #'universal-argument
      :m "<kp-subtract>" #'negative-argument
      :m "−"             #'negative-argument) ; Real Minus.
#+end_src

** Whitespace
Don’t turn on ~whitespace-mode~ automatically.
#+begin_src emacs-lisp
(defadvice! *doom--disable-automatic-whitespace-mode-a (&rest _)
  "Don’t turn on `whitespace-mode' on startup."
  :after #'doom-init-ui-h
  (remove-hook 'after-change-major-mode-hook
               #'doom-highlight-non-default-indentation-h))
#+end_src

#+begin_src emacs-lisp
(after! whitespace
  (setq whitespace-style
        '(face
          indentation
          lines-tail
          empty
          tabs
          tab-mark
          space-before-tab
          space-after-tab)))
#+end_src

** Workspaces
#+begin_src emacs-lisp
(defvaralias '+workspace-list 'persp-names-cache)
#+end_src

#+begin_src emacs-lisp
(defvar doom-leader-workspace-transient-map (make-sparse-keymap))
(map! :map doom-leader-workspace-map
      "<left>" #'+workspace/switch-left
      "<right>" #'+workspace/switch-right
      :map doom-leader-workspace-transient-map
      "<left>"   #'+workspace/switch-left
      "<right>"  #'+workspace/switch-right
      "["        #'+workspace/switch-left
      "]"        #'+workspace/switch-right)
#+end_src

#+begin_src emacs-lisp
(defadvice! *workspace--ask-before-deleting-a (&rest _)
  :before-while #'+workspace/delete
  (if current-prefix-arg t
    (y-or-n-p (format "Really delete workspace (%s): " (+workspace-current-name)))))
#+end_src

#+begin_src emacs-lisp
(defadvice! *workspace--transient-map-on-switch-a ()
  :after #'+workspace/display
  (set-transient-map doom-leader-workspace-transient-map))
#+end_src

#+begin_src emacs-lisp
(defadvice! *persp-dont-prevent-kill-emacs (_)
  :filter-return #'persp-kill-emacs-query-function
  t)
#+end_src

*** TODO Rework the workspaces module to use =tab-bar=
* Packages
** Avy
Set ~avy-keys~ to the Neo2 homerow on =PhantomJFL=.
#+begin_src emacs-lisp
(when IS-PHANTOM
  (setq avy-keys (string-to-list "uiaeosnrtdy")))
#+end_src

** Company
*** Box
#+begin_src emacs-lisp :tangle no
(when (featurep! :completion company +childframe)
  (defadvice! *company-box-line-numbers-a (&rest _)
    :after #'company-box--render-buffer
    (with-current-buffer (company-box--get-buffer)
      (setq display-line-numbers company-show-numbers
            display-line-numbers-width 1)
      (face-remap-add-relative
       'line-number :foreground "#bbc2cf"))))
#+end_src

Also see [[github:sebastiencs/company-box/issues/138][=company-box/#138=]].
#+begin_src emacs-lisp
(when (featurep! :completion company +childframe)
  (defadvice! *company-box-fixes-a (string on-update)
    :before #'company-box--render-buffer
    (unless on-update
      (with-current-buffer (company-box--get-buffer)
        (setq line-spacing 0)))))
#+end_src

*** Quickhelp
#+begin_src emacs-lisp
(use-package! company-quickhelp
  :when (and (featurep! :completion company)
             (not (featurep! :completion company +childframe)))
  :after company
  :hook (company-mode-hook . company-quickhelp-local-mode)
  :config (setq company-quickhelp-use-propertized-text nil))
#+end_src

** Embrace
The standard [[github:cute-jumper/embrace.el][=embrace.el=]] does not provide a way to add global pair definitions,
so I define such functions myself.
#+begin_src emacs-lisp
(defun embrace-add-default-pair (key left right &optional help auto-newline)
  "Like `embrace-add-pair', but for all major modes."
  (setf (alist-get key (default-value 'embrace--pairs-list))
        (make-embrace-pair-struct
         :key key
         :left left
         :right right
         :left-regexp (regexp-quote left)
         :right-regexp (regexp-quote right)
         :help help
         :auto-newline auto-newline)))

(defun embrace-add-default-pair-regexp
    (key left-regexp right-regexp read-function &optional help auto-newline)
  "Like `embrace-add-pair-regexp', but for all major modes."
  (setf (alist-get key (default-value 'embrace--pairs-list))
        (make-embrace-pair-struct
         :key key
         :read-function read-function
         :left-regexp left-regexp
         :right-regexp right-regexp
         :help help
         :auto-newline auto-newline)))
#+end_src

These bindings allow me to easily surround the selection with empty lines.
#+begin_src emacs-lisp
(after! embrace
  (embrace-add-default-pair ?o "" "\n")
  (embrace-add-default-pair ?O "\n" "")
  (embrace-add-default-pair ?\r "\n" "\n"))
#+end_src

** Evil
*** Preamble
Wrap the whole section into a conditional. I would use =noweb= for this, but the
=org-babel= implementation is /very/ slow.
#+begin_src emacs-lisp
(when (featurep! :editor evil) ;; Intentional missing paren.
#+end_src

*** Evil Mode
Evil uses Vim’s undo increments by default, which are too coarse for me.
#+begin_src emacs-lisp
(setq evil-want-fine-undo t)
#+end_src

Automatic conversion of tabs seems to be broken.
#+begin_src emacs-lisp
(setq evil-indent-convert-tabs nil)
#+end_src

Switch to the new window after splitting.
#+begin_src emacs-lisp
(setq evil-split-window-below  t
      evil-vsplit-window-right t)
#+end_src

Some variables to try out. I’m tempted to enable ~evil-visual-region-expanded~,
but I fear that might break some things.
#+begin_src emacs-lisp
(setq evil-move-beyond-eol        nil
      evil-move-cursor-back       nil
      evil-kill-on-visual-paste   nil
      evil-visual-region-expanded nil)
#+end_src

The =smart= option sometimes upcases the entire replacement string.
#+begin_src emacs-lisp
(setq evil-ex-substitute-case 'sensitive)
(setq evil-ex-substitute-global t)
#+end_src

Evil should deactivate itself in these modes.
#+begin_src emacs-lisp
(after! evil
  (evil-set-initial-state 'calc-mode  'emacs)
  (evil-set-initial-state 'dired-mode 'emacs))
#+end_src

We can’t use ~defvaralias~ here, because ~evil-mode~ is already running
which causes ~evil-shift-width~ to be a localized variable.
#+begin_src emacs-lisp
;; (defvaralias 'evil-shift-width 'standard-indent)
#+end_src

Make the WORD motion functions use syntactic symbols instead of WORDs.
#+begin_src emacs-lisp
(defalias #'forward-evil-WORD #'forward-evil-symbol)
#+end_src

Alias for consistency.
#+begin_src emacs-lisp
(defalias #'evil-forward-WORD #'forward-evil-WORD)
#+end_src

Define =evil-word= and =evil-WORD= as =thingatpt.el= things.
#+begin_src emacs-lisp :tangle no
(put 'evil-word 'forward-op   #'evil-forward-word)
(put 'evil-word 'beginning-op #'evil-forward-word-begin)
(put 'evil-word 'end-op       #'evil-forward-word-end)
(put 'evil-WORD 'forward-op   #'evil-forward-WORD)
(put 'evil-WORD 'beginning-op #'evil-forward-WORD-begin)
(put 'evil-WORD 'end-op       #'evil-forward-WORD-end)
;;(setq evil-mouse-word 'evil-word)
#+end_src

#+begin_src emacs-lisp
(defadvice! *evil--fix-evil-set-cursor-a (spec)
  "Fix `evil-set-cursor' breaking when a spec has a function binding."
  :after #'evil-set-cursor
  (when (memq spec '(box bar hbar)) (setq cursor-type spec)))
#+end_src

Fix double-click selection in ~evil-mode~.
#+begin_src emacs-lisp
(defadvice! *evil--fix-mouse-start-end-a (orig-fn start end mode)
  "Make `mouse-start-end' handle the `evil-mode' point/region convention.
Without this, double-click selection in `evil-mode' extends one
character too far."
  :around #'mouse-start-end
  (if (and (= mode 1)
           (bound-and-true-p evil-local-mode)
           (not (or (evil-insert-state-p) (evil-emacs-state-p))))
      (cl-destructuring-bind (start end) (funcall orig-fn start end mode)
        (list start (1- end)))
    (funcall orig-fn start end mode)))
#+end_src

#+begin_src emacs-lisp
(map! :after evil
      ;; Use the default `mouse-drag-region'.
      :m "<mouse-down-1>" #'mouse-drag-region

      ;; Remap the document scroll motions to something more sensible.
      :m "z+" nil
      :m "z-" nil
      :m "z^" nil
      :m "z." nil
      :m "zT" #'evil-scroll-bottom-line-to-top
      :m "zB" #'evil-scroll-top-line-to-bottom
      :m "z S-<right>" #'evil-scroll-right
      :m "z S-<left>" #'evil-scroll-left

      ;; Make DEL/<backspace> remove text.
      :n "DEL" #'evil-delete-backward-char

      ;; Map the arrow keys in Evils window map.
      (:map evil-window-map
       "<up>"      #'evil-window-up
       "<down>"    #'evil-window-down
       "<left>"    #'evil-window-left
       "<right>"   #'evil-window-right
       "S-<up>"    #'+evil/window-move-up
       "S-<down>"  #'+evil/window-move-down
       "S-<left>"  #'+evil/window-move-left
       "S-<right>" #'+evil/window-move-right
       "C-h"       nil
       "C-j"       nil
       "C-k"       nil
       "C-l"       nil))
#+end_src

#+begin_src emacs-lisp
(map! :after evil
      :map evil-motion-state-map
      "<home>" #'move-beginning-of-line
      "<end>"  #'move-end-of-line
      "gh"     #'beginning-of-defun
      "g["     #'backward-page
      "g]"     #'forward-page)
#+end_src

Workaround for ~evil-buffer-new~ calling ~set-window-buffer~ instead of
~switch-to-buffer~. See issue [[doom-repo:issues/4514][#4514]].
#+begin_src emacs-lisp
(defadvice! +evil--new-buffer-a (orig-fn count file)
  :around #'evil-buffer-new
  (if file
      (funcall orig-fn count file)
    (with-current-buffer (switch-to-buffer (generate-new-buffer "*new*"))
      (funcall (default-value 'major-mode)))))
#+end_src

*** Evil Cleverparens
This package seems like a nice idea, but it has caused me lots of grief on top
of being abandoned since 2017 and being quite massive. Most of the stuff I
actually used should be possible to reimplement.
#+begin_src emacs-lisp :tangle no
(use-package! evil-cleverparens
  :when (featurep! :editor evil)
  :after (evil smartparens)
  :hook (lisp-mode-common . evil-cleverparens-mode)
  :init
  (setq evil-cleverparens-indent-afterwards nil) ; Messes up `comment-column'.
  (setq evil-cleverparens-move-skip-delimiters nil) ; Maybe try this.
  (setq evil-cleverparens-use-regular-insert nil) ; Trying this out.
  (setq evil-cleverparens-use-s-and-S nil) ; We are using `evil-snipe'.
  ;; These interfere with `macrostep-mode'.
  (setq evil-cp-regular-movement-keys nil)
  (setq evil-cp-swapped-movement-keys nil)
  (map! :textobj "c" #'evil-cp-inner-comment #'evil-cp-a-comment
        :textobj "d" #'evil-cp-inner-defun   #'evil-cp-a-defun
        :textobj "f" #'evil-cp-inner-form    #'evil-cp-a-form)
  ;; These functions are used to populate `evil-cleverparens-mode-map'.
  ;; (advice-add #'evil-cp-set-movement-keys    :override #'ignore)
  ;; Unnecessary, since we define the text objects ourselves.
  ;; (advice-add #'evil-cp--enable-text-objects :override #'ignore)
  :config
  (map! :map evil-cleverparens-mode-map :leader :prefix "t"
        :desc "Balanced yank" "y" #'evil-cp-toggle-balanced-yank))
#+end_src

*** Evil Collection
Doom Emacs loads the ~evil-collection~ packages manually and needs the
corresponding variables to be set beforehand. The code below runs
right before ~+evil-collection-init~ first called.
#+begin_src emacs-lisp
(when (and (featurep! :editor evil +everywhere)
           doom-interactive-p
           (not doom-reloading-p)
           (not (memq 'evil-collection doom-disabled-packages)))
  (add-transient-hook! #'+evil-collection-init
    (push! +evil-collection-disabled-list
           'calc 'tetris '2084-game 'haskell-error-mode)))
#+end_src

*** Evil Jump
The package [[github:redguardtoo/evil-matchit][=evil-matchit=]] allows jumping between language-specific tags, but is
not very configurable otherwise. Also it relies on dynamic binding.
#+begin_src emacs-lisp
(use-package! evil-matchit
  :when (featurep! :editor evil)
  :commands evilmi--operate-on-item)
#+end_src

This fantastic command combines all the best aspects of ~*sp-jump-item~,
~evilmi-jump-items~ and ~evil-jump-items~!
#+begin_src emacs-lisp
(evil-define-motion *evil-jump-item (count)
  "Combine `*sp-jump-item', `evilmi-jump-items' and `evil-jump-item'.
The best of all aforementioned worlds, so jumping just works™."
  :jump t
  :type exclusive
  (or (when count (evil-jump-item count) t)
      (when smartparens-mode (*sp-jump-item))
      (when (fboundp 'evilmi-jump-items) (evilmi--operate-on-item nil))
      (evil-jump-item)))
#+end_src

#+begin_src emacs-lisp
(map! :m "%" #'*evil-jump-item)
#+end_src

*** Evil Multiple Cursors
#+begin_src emacs-lisp
(map! :when (featurep! :editor multiple-cursors)
      :after evil-mc
      :nv "g z <up>"   #'evil-mc-make-cursor-move-prev-line
      :nv "g z <down>" #'evil-mc-make-cursor-move-next-line)
#+end_src

*** Evil Numbers
Remap the ~inc-at-pt~ functions, so =z == can be used for formatting.
#+begin_src emacs-lisp
(map! :after evil-numbers
      :nv "g +" #'evil-numbers/inc-at-pt
      :nv "g -" #'evil-numbers/dec-at-pt
      :v  "z +" #'evil-numbers/inc-at-pt-incremental
      :v  "z -" #'evil-numbers/dec-at-pt-incremental)
#+end_src

*** Evil Nerd Commenter
With ~visual-line-mode~ active, ~evilnc-comment-operator~ uncomments two lines
instead of one, if the next line begins with a comment sign. This is likely
caused by ~evilnc-comment-operator~ not handling a region of type =screen-line=
correctly, which is why we have to fix the region bounds manually.
It might also just be a bug in =evil= itself, who knows?
#+begin_src emacs-lisp
(defadvice! *evilnc-fix-visual-line-mode-a (args)
  "For ARGS = (BEG END TYPE) decrement END if (eq TYPE 'screen-line)."
  :filter-args #'evilnc-comment-operator
  (when (eq (nth 2 args) 'screen-line) (cl-decf (nth 1 args)))
  args)
#+end_src

*** Evil Snipe
Put ~evil-snipe-repeat~ on Comma and Shift-Comma.
#+begin_src emacs-lisp :tangle no
(map! :after evil-snipe
      :map (evil-snipe-parent-transient-map
            evil-snipe-override-mode-map
            evil-snipe-override-local-mode-map)
      :m "," #'evil-snipe-repeat
      :m "–" #'evil-snipe-repeat-reverse
      :m ";" nil)
#+end_src

*** Evil Org
The =evil-org= package is only loaded when the =+everywhere= flag is set.

Doom Emacs changes ~org-cycle~ to skip the =subtree= stage by default when
~(featurep! :editor evil +everywhere)~.
#+begin_src emacs-lisp
(after! evil-org
  (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h))
#+end_src

Add block jumping to =[= and =]= and remap =z r= and =z m= to =z O= and =z C=.
Furthermore, =evil-org= rebinds =C-h= in =insert-state=, which is not very
discoverable. See [[doom-modules:lang/org/config.el][=lang/org/config.el=]] for the concrete bindings; particularly
the lines 973 to 1026.
#+begin_src emacs-lisp
(map! :after evil-org
      (:map evil-org-mode-map
       :m "[ _" #'org-previous-block
       :m "] _" #'org-next-block
       :n "z r" nil
       :n "z m" nil
       :n "z O" #'+org/show-next-fold-level
       :n "z C" #'+org/hide-next-fold-level
       :i "C-h"   nil :i "C-j"   nil :i "C-k"   nil :i "C-l"   nil
       :i "C-S-h" nil :i "C-S-j" nil :i "C-S-k" nil :i "C-S-l" nil)
      (:after org-keys :map org-read-date-minibuffer-local-map
       :i "C-h"   nil :i "C-j"   nil :i "C-k"   nil :i "C-l"   nil
       :i "C-S-h" nil :i "C-S-j" nil :i "C-S-k" nil :i "C-S-l" nil))
#+end_src

*** Operators
This operator capitalizes a region similar to ~evil-upcase~ and ~evil-downcase~.
#+begin_src emacs-lisp
(evil-define-operator *evil-capitalize (beg end type)
  "Capitalize text."
  (if (eq type 'block)
      (evil-apply-on-block #'*evil-capitalize beg end nil)
    (capitalize-region beg end)))
(map! :n "g C-u" #'*evil-capitalize
      :v   "C-u" #'*evil-capitalize)
#+end_src

*** Text Objects
#+begin_src emacs-lisp
(evil-define-text-object *evil-inner-defun (count &optional beg end type)
  (evil-select-inner-object 'defun beg end type count))

(evil-define-text-object *evil-a-defun (count &optional beg end type)
  (evil-select-an-object 'defun beg end type count 'line))

(map! :textobj "d" #'*evil-inner-defun #'*evil-a-defun)
#+end_src

#+begin_src emacs-lisp
(evil-define-text-object *evil-inner-form (count &optional beg end type)
  (sp-get (sp-get-sexp count)
    (when (<= :beg (point) :end) (evil-range :beg-in :end-in type))))

(evil-define-text-object *evil-a-form (count &optional beg end type)
  (sp-get (sp-get-sexp count)
    (when (<= :beg (point) :end) (evil-range :beg :end type))))

(map! :textobj "f" #'*evil-inner-form #'*evil-a-form)
#+end_src

*** NOTE Other Packages
More Evil-related packages that I might try out some time.
+ [[https://github.com/willghatch/emacs-on-parens][on-parens]]
+ [[https://github.com/expez/evil-smartparens][evil-smartparens]]

*** Postamble
Close the conditional opened in the preamble.
#+begin_src emacs-lisp
) ;; (when (featurep! :editor evil))
#+end_src

** Flycheck
#+begin_src emacs-lisp
(map! :when (featurep! :checkers syntax)
      :after flycheck
      ;; Map double exclamation mark.
      (:map flycheck-command-map "!" #'flycheck-buffer)
      ;; Name the flycheck prefix keys.
      (:leader :prefix "c"
       (:prefix ("!" . "flycheck") "" flycheck-command-map))
      (:map flycheck-mode-map :prefix "C-c"
       (:prefix ("!" . "flycheck") "" flycheck-command-map)))
#+end_src

** Hungry Delete
These functions delete all whitespace up to the next non-whitespace character.
#+begin_src emacs-lisp
(use-package! hungry-delete
  :bind (("M-DEL"      . hungry-delete-backward)
         ("M-<delete>" . hungry-delete-forward)))
#+end_src

** Info
Treat ~info~ buffers as real buffers.
#+begin_src emacs-lisp
(after! info (set-popup-rule! "^\\*info\\*$" :ignore t))
#+end_src

** Ivy
Don’t show =../= in file completion buffer.
#+begin_src emacs-lisp
(setq ivy-extra-directories '("./"))
#+end_src

Ivy should recurse into directories when pressing =RET=.
#+begin_src emacs-lisp
(map! :when (featurep! :completion ivy)
      :after ivy
      :map ivy-minibuffer-map
      "<return>"   #'ivy-alt-done
      "C-<return>" #'ivy-immediate-done
      "C-l"        #'ivy-done
      "C-<up>"     #'ivy-previous-history-element
      "C-<down>"   #'ivy-next-history-element)
#+end_src

*** NOTE Counsel Compile
Currently Doom maps =SPC c c= and =SPC p c= to ~+ivy/compile~ and
~+ivy/project-compile~ which are specialized versions of ~counsel-compile~.
I would like to have some key bound to ~counsel-compile~, but I first need to
experiment a bit with the current system.

** Magit
#+begin_src emacs-lisp
(add-hook   'git-commit-setup-hook #'turn-off-flyspell)
(setq-hook! 'git-commit-setup-hook fill-column 50)
#+end_src

This fixes an issue where Magit doesn’t unfold the headings in ~org-mode~.
Reported to Doom as [[doom-repo:issues/4895][#4895]] and fixed in [[doom-repo:commit/3e425ab2f2bcc634ea0948c464f98e5120a2176b][3e425ab]].
#+begin_src emacs-lisp :tangle no
(add-hook! 'org-mode-hook
  (defun *magit--call-org-reveal-h ()
    "Add `org-reveal' to `magit-diff-visit-file-hook' to reveal point."
    (add-hook 'magit-diff-visit-file-hook #'org-reveal nil 'local)))
#+end_src

** Org
*** Org Mode
#+begin_src emacs-lisp
(setq org-cycle-global-at-bob t
      org-cycle-include-plain-lists nil
      org-directory (expand-file-name "~/text/org/")
      org-startup-folded t)
#+end_src

Use hard line wrapping to keep all columns shorter than ~fill-column~.
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook
  (defun *org--enable-hard-line-wrapping-h ()
    (visual-line-mode -1)
    (auto-fill-mode +1)))
#+end_src

Don’t start ~flyspell-mode~ automatically.
#+begin_src emacs-lisp
(remove-hook 'org-mode-hook #'flyspell-mode)
#+end_src

Add ~company-capf~ as a Company backend.
#+begin_src emacs-lisp
(set-company-backend! 'org-mode 'company-capf)
#+end_src

#+begin_src emacs-lisp
(after! smartparens
  (cl-dolist (del '("=" "~"))
    (sp-local-pair 'org-mode del del
                   :unless '(sp-point-before-word-p
                             sp-point-after-word-p
                             sp-point-before-same-p))))
#+end_src

#+begin_src emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'org-mode
    "C-c C-x" "more"
    "C-c C-v" "babel"
    "C-c \""  "plot"))
#+end_src

*** Org Babel
#+begin_src emacs-lisp :tangle no
(defun *org-babel-tangle-file-async (file &optional target-file lang-re finish-func)
  (require 'async)
  (async-start
   (apply-partially #'org-babel-tangle-file target-file lang-re)
   finish-func))
#+end_src

*** Org Indent
#+begin_src emacs-lisp
(add-hook! 'org-mode-local-vars-hook
  (defun *org-indent--local-init-h ()
    (when (bound-and-true-p org-indent-mode)
      ;; For some reason, `show-smartparens-mode' causes visual glitches.
      (when (bound-and-true-p show-smartparens-mode)
        (show-smartparens-mode -1))
      ;; The indicator doesn’t take the visual indentation into account.
      (when (and EMACS27+ display-fill-column-indicator)
        (display-fill-column-indicator-mode -1)))))
#+end_src

*** Org Keys
Bind shortcuts for navigating headings with the arrow keys.
Add ~org-babel-map~ to ~:localleader~.
#+begin_src emacs-lisp
(map! :after org-keys
      :map org-mode-map
      "C-<left>"  (cmds! (org-at-table-p) #'org-table-previous-field
                         #'org-beginning-of-line)
      "C-<right>" (cmds! (org-at-table-p) #'org-table-next-field
                         #'org-end-of-line)
      "C-<up>"    (cmds! (org-at-table-p) #'org-table-previous-field
                         #'org-beginning-of-line)
      "C-<down>"  (cmds! (org-at-table-p) #'org-table-next-row
                         #'org-down-element)
      "C-M-<left>"  #'org-up-element
      "C-M-<right>" #'org-down-element
      "C-M-<up>"    #'org-previous-visible-heading
      "C-M-<down>"  #'org-next-visible-heading
      (:localleader :prefix ("v" . "babel") "" org-babel-map))
#+end_src

*** Org Modules
These values have to be set before ~org-mode~ is loaded.
#+begin_src emacs-lisp
(setq org-modules
      '(;; ol-w3m
        ;; ol-bbdb
        ol-bibtex
        ;; ol-docview
        ;; ol-gnus
        ol-info
        ;; ol-irc
        ;; ol-mhe
        ;; ol-rmail
        ;; ol-eww
        ))
#+end_src

*** Org Source
#+begin_src emacs-lisp
(after! org-src
  (push! org-src-lang-modes
         '("dash" . sh)
         '("zsh"  . sh)))
#+end_src

** Projectile
#+begin_src emacs-lisp
(map! :after projectile
      :map projectile-mode-map
      :leader :prefix "p"
      :desc "M-x in root" ":" #'projectile-run-command-in-root
      :desc "Shell command in root" "!" #'projectile-run-shell-command-in-root
      :desc "Async command in root" "&" #'projectile-run-async-shell-command-in-root)
#+end_src

** Smartparens
Add this pair in ~sp-lisp-modes~ for symmetry.
#+begin_src emacs-lisp
(after! smartparens
  (sp-pair "\\\\(" "\\\\)" :actions :rem)
  (cl-dolist (pair '(("\\(" . "\\)") ("\\[" . "\\]") ("\\{" . "\\}")))
    (sp-local-pair sp-lisp-modes
                   (car pair) (cdr pair)
                   :actions '(insert wrap autoskip navigate)
                   :when '(:add sp-in-string-p))))
#+end_src

Bind ~sp-raise-sexp~, which I use quite often.
#+begin_src emacs-lisp
(map! :n "z +" #'sp-join-sexp
      :n "z -" #'sp-split-sexp
      :n "z r" #'sp-raise-sexp
      :n "z s" #'sp-splice-sexp
      :n "z v" #'sp-convolute-sexp)
#+end_src

#+begin_src emacs-lisp
(map! :prefix ("ß" . "smartparens")
      :n ")" #'sp-forward-slurp-sexp
      :n "C-)" #'sp-slurp-hybrid-sexp
      :n "<" #'sp-backward-barf-sexp
      :n ">" #'sp-forward-barf-sexp
      :n "[" #'sp-add-to-next-sexp
      :n "]" #'sp-add-to-previous-sexp
      :n "{" #'sp-splice-sexp-killing-backward
      :n "}" #'sp-splice-sexp-killing-forward
      :n "+" #'sp-join-sexp
      :n "-" #'sp-split-sexp
      :n "d" #'sp-kill-sexp
      :n "D" #'sp-kill-hybrid-sexp
      :n "j" #'sp-down-sexp
      :n "J" #'sp-join-sexp
      :n "k" #'sp-up-sexp
      :n "n" #'sp-next-sexp
      :n "p" #'sp-previous-sexp
      :n "q" #'sp-indent-defun
      :n "r" #'sp-raise-sexp
      :n "s" #'sp-splice-sexp
      :n "S" #'sp-split-sexp
      :n "t" #'sp-transpose-sexp
      :n "T" #'sp-transpose-hybrid-sexp
      :n "u" #'sp-unwrap-sexp
      :n "v" #'sp-convolute-sexp
      :n "w (" #'sp-wrap-round
      :n "w )" #'sp-wrap-round
      :n "w [" #'sp-wrap-square
      :n "w ]" #'sp-wrap-square
      :n "w {" #'sp-wrap-curly
      :n "w }" #'sp-wrap-curly)
#+end_src

#+begin_src emacs-lisp
(after! smartparens
  (setcar (assoc "M-<up>"   sp-paredit-bindings) "C-<up>")
  (setcar (assoc "M-<down>" sp-paredit-bindings) "C-<down>"))
#+end_src

This is a function that I have been sorely missing. Using code from
~sp-show--pair-function~, I can finally use =smartparens= to jump between pairs.
#+begin_src emacs-lisp
(defun *sp-jump-item ()
  "Like `evil-jump-item', but using `sp-pairs'."
  (interactive)
  (save-match-data
    (let (match back)
      (let* ((pair-list (sp--get-allowed-pair-list))
             (opening (sp--get-opening-regexp pair-list))
             (closing (sp--get-closing-regexp pair-list)))
        (cond ((and (not (*evil-blocky-state-p))
                    (sp--looking-back closing))
               (setq match (match-string 0) back t))
              ((or (and (*evil-blocky-state-p)
                        (sp--looking-at (sp--get-allowed-regexp)))
                   (sp--looking-at opening)
                   (looking-at (sp--get-stringlike-regexp))
                   (and (memq major-mode sp-navigate-consider-sgml-tags)
                        (sp--looking-at "<")))
               (setq match (match-string 0)))
              ((or (sp--looking-back closing)
                   (sp--looking-back (sp--get-stringlike-regexp))
                   (and (memq major-mode sp-navigate-consider-sgml-tags)
                        (sp--looking-back ">")))
               (setq match (match-string 0) back t))))
      (when match
        (when-let* ((ok (sp-get-thing back)))
          (sp-get ok
            (cond ((<  (point) :beg-in) (goto-char :end-in))
                  ((<= :end-in (point)) (goto-char :beg)))))))))
#+end_src

*** NOTE Smartparens matching character literals ([[github:Fuco1/smartparens/issues/1045][#1045]])
This is caused by [[doom-modules:config/default/config.el][=config.el=]] on lines 80–86 defining
~doom-disable-smartparens-navigate-skip-match-h~ which sets
~sp-navigate-skip-match~ to ~nil~ for performance reasons.
Doom offers ~show-paren-mode~ and Evil’s =%= as replacement.

This behavior can be deactivated with the advice below.
#+begin_src emacs-lisp :tangle no
(defadvice! *doom-dont-disable-smartparens-navigate-skip-match-a ()
  :override #'doom-disable-smartparens-navigate-skip-match-h)
#+end_src

*** DONE Smartparens pairing single quotes in minibuffer ([[doom-repo:pull/4944][#4944]])
Doom already has a fix for this, but only in =minibuffer-inactive-mode=.
#+begin_src emacs-lisp :tangle no
(after! smartparens
  (sp-local-pair 'minibuffer-mode "`" nil :actions nil)
  (sp-local-pair 'minibuffer-mode "'" nil :actions nil))
#+end_src

*** DONE Closing paren deleted twice ([[https://github.com/hlissner/doom-emacs/issues/3268][#3268]])
This is currently broken, in that two closing delimiters are deleted instead of
one. As the linked issue is resolved, this fix is no longer necessary.
#+begin_src emacs-lisp :tangle no
(setq sp-autodelete-pair nil)
#+end_src

** Which Key
Replace =<up>= and =<down>= with Unicode arrows.
#+begin_src emacs-lisp
(after! which-key
  (push! which-key-replacement-alist
         '(("<up>"   . nil) . ("↑" . nil))
         '(("<down>" . nil) . ("↓" . nil))))
#+end_src

These are some default keybindings that are missing a description.
#+begin_src emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-x"      '("global" . "Global commands")
    "C-x RET"  "locale"
    "C-x ESC"  "complex-repeat"

    "C-x 4"    "other-window"
    "C-x 5"    "other-frame"
    "C-x 6"    "two-column"
    "C-x 8"    '("unicode" . "Unicode symbols")

    "C-x @"    '("apply-modifier" . "Add a modifier to the next event")
    "C-x a"    "abbrev"
    "C-x a i"  "inverse"
    "C-x n"    "narrow"
    "C-x r"    "rectangle/register"
    "C-x t"    "tab-bar"
    "C-x v"    "version-control"
    "C-x X"    "edebug"

    "C-c"      '("mode-specific" . "Mode specific commands")

    "M-s"      "search"
    "M-s h"    "highlight"
    "M-g"      "goto"))
#+end_src

** Yasnippet
In ~snippet-mode~, whitespace has significant meaning.
#+begin_src emacs-lisp
(after! ws-butler
  (push 'snippet-mode ws-butler-global-exempt-modes))
#+end_src

#+begin_src emacs-lisp
(when EMACS27+
  (add-hook! 'snippet-mode-hook (display-fill-column-indicator-mode -1)))
#+end_src

#+begin_src emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-c &" "snippet"))
#+end_src

#+begin_src emacs-lisp
(when (featurep! :editor evil)
  (defadvice! *yas--evil-insert-state-on-expand-snippet-a (&rest _)
    :before #'yas-expand-snippet
    (when evil-mode (evil-insert-state))))
#+end_src

* Languages
** Arduino
#+begin_src emacs-lisp
(setq arduino-mode-home (expand-file-name "~/src/arduino/"))
#+end_src

This only works with a *patched* Arduino runtime.
#+begin_src emacs-lisp
(when (sys-feature-p 'arduino/xdg)
  (let ((pref-file (expand-file-name "arduino/preferences.txt" XDG-DATA-HOME)))
    (when (file-readable-p pref-file)
      (setq ede-arduino-preferences-file pref-file))))
#+end_src

** Assembler
#+begin_src emacs-lisp
(setq-hook! 'asm-mode-hook
  tab-width 8
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(defadvice! *asm--add-indentation-rules-a (&rest _)
  "Add rule clauses to `asm-calculate-indentation'."
  :before-until #'asm-calculate-indentation
  (and (looking-at "section") 0))
#+end_src

*** x86 Lookup
#+begin_src emacs-lisp :tangle no
(use-package! x86-lookup
  :defer t
  :init (set-lookup-handlers! 'asm-mode :documentation #'x86-lookup)
  :config
  (setq x86-lookup-pdf "/usr/local/share/doc/intel-x86/325383-sdm-vol-2abcd.pdf")
  (setq x86-lookup-cache-directory (expand-file-name "x86-lookup" doom-cache-dir)))
#+end_src

Checking code for =doom doctor=.
#+begin_src emacs-lisp :tangle no
(when (require 'x86-lookup nil t)
  (cond ((null x86-lookup-pdf)
         (warn! "`x86-lookup-pdf' is not set. Go-to-definition will not work."))
        ((not (file-exists-p x86-lookup-pdf))
         (warn! "Couldn't find Intel x86 documentation PDF. Check `x86-lookup-pdf'."))))
#+end_src

** BASIC
#+begin_src emacs-lisp
(defvaralias 'basic-indent-offset 'standard-indent)
(defvaralias 'fbasic-indent-level 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'basic-mode-hook
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'fbasic-mode-hook
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'basic-mode-hook
    +fmt-formatter #'basic-format-code)
  (setq-hook! 'fbasic-mode-hook
    +fmt-formatter #'indent-region))
#+end_src

** C/C++
*** Code Style
#+begin_src emacs-lisp
(defvaralias 'c-basic-offset 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(after! cc-mode
  (c-add-style
   "jfl"
   '((c-basic-offset   . 4)
     (tab-width        . 4)
     (indent-tabs-mode . t)

     (c-comment-only-line-offset . 0)
     (c-hanging-braces-alist
      (brace-list-open)
      (brace-entry-open)
      (substatement-open after)
      (block-close . c-snug-do-while)
      (arglist-cont-nonempty))
     (c-cleanup-list
      brace-else-brace
      brace-elseif-brace
      brace-catch-brace)
     (c-offsets-alist
      (inline-open        . 0)
      (knr-argdecl-intro  . 0)
      (substatement-open  . 0)
      (substatement-label . 0)
      (case-label         . 0)
      (access-label       . -)
      (label              . 0))))

  (setq c-default-style
        '((awk-mode  . "awk")
          (java-mode . "java")
          (other     . "jfl"))))
#+end_src

*** C Mode
*** C++ Mode
*** File Templates
#+begin_src emacs-lisp
(set-file-templates!
 '("/main\\.c\\(?:c\\|pp\\)$") '("/win32_\\.c\\(?:c\\|pp\\)$")
 '("\\.c\\(?:c\\|pp\\)$") '("\\.h\\(?:h\\|pp\\|xx\\)$") '("\\.h$") '(c-mode)
 '(c-mode :trigger "__src") '(c++-mode :trigger "__src")
 (list "\\.h\\(?:h\\|pp\\|xx\\|\\+\\+\\)?\\'" :trigger "__hdr_pragma"
       :when (lambda () (bound-and-true-p *cc-use-pragma-once)))
 '("\\.h\\(?:h\\|pp\\|xx\\|\\+\\+\\)?\\'" :trigger "__hdr")
 '("/main\\.c\\(?:c\\|pp\\|xx\\|\\+\\+\\)?\\'" :trigger "__main")
 '("/win32_main\\.c\\(?:c\\|pp\\)\\'" :trigger "__winmain"))
#+end_src

*** Meson Mode
Major mode for the [[https://mesonbuild.com][Meson Build System]].

Integrate =meson-mode= with the Doom lookup system.
#+begin_src emacs-lisp
(set-lookup-handlers! 'meson-mode
  :documentation #'meson-lookup-doc)
#+end_src

Specify where to find the Meson documentation, if installed.
#+begin_src emacs-lisp
(after! meson-mode
  (let ((dir (expand-file-name "/usr/local/share/doc/meson-0.55.0/")))
    (when (file-accessible-directory-p dir)
      (setq meson-markdown-docs-dir dir))))
#+end_src

Add the =meson.build= file to the files that projectile looks for when
determining the project root directory.
#+begin_src emacs-lisp
(after! projectile
  (push "meson.build" projectile-project-root-files))
#+end_src

*** LSP
Activate the =clang-tidy= integration of =clangd=.
#+begin_src emacs-lisp
(setq lsp-clients-clangd-args '("--clang-tidy"))
#+end_src

*** Flycheck
#+begin_src emacs-lisp
(when (featurep! :checkers syntax)
  (setq-hook! 'c-mode-hook
    flycheck-gcc-language-standard   "gnu18"
    flycheck-clang-language-standard "gnu18"))
#+end_src

#+begin_src emacs-lisp
(when (featurep! :checkers syntax)
  (setq-hook! 'c++-mode-hook
    flycheck-gcc-language-standard   "gnu++17"
    flycheck-clang-language-standard "gnu++17"))
#+end_src

#+begin_src emacs-lisp
(when (featurep! :checkers syntax)
  (defvar *flycheck-gcc-header-warnings '("no-pragma-once-outside-header")
    "A list of warnings to be added to `flycheck-gcc-warnings' when editing a C/C++ header file.")
  (defvar *flycheck-clang-header-warnings '("no-pragma-once-outside-header")
    "A list of warnings to be added to `flycheck-clang-warnings' when editing a C/C++ header file.")
  (add-hook! '(c-mode-hook c++-mode-hook)
    (defun *flycheck--maybe-add-gcc-clang-header-warnings-h ()
      (when (and buffer-file-name (*cc-header-file-p buffer-file-name))
        (setq-local
         flycheck-gcc-warnings
         (append *flycheck-gcc-header-warnings flycheck-gcc-warnings)
         flycheck-clang-warnings
         (append *flycheck-clang-header-warnings flycheck-clang-warnings))))))
#+end_src

#+begin_src emacs-lisp
(use-package! flycheck-clang-tidy
  :when (featurep! :checkers syntax)
  :after flycheck
  :hook (flycheck-mode-hook . flycheck-clang-tidy-setup))
#+end_src

*** Smartparens
Add automatic bracket spacing in ~sp-c-modes~, which is removed in =smartparens-c.el=.
#+begin_src emacs-lisp
(after! smartparens-c
  (sp-with-modes sp-c-modes
    (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))))
#+end_src

** Clojure :Lisp:
#+begin_src emacs-lisp
(add-hook 'clojure-mode-hook #'lisp-mode-common-hook)
#+end_src

** Common Lisp :Lisp:
In accordance with the [[https://lisp-lang.org/style-guide/][Common Lisp Style Guide]].
#+begin_src emacs-lisp
(setq-hook! 'lisp-mode-hook
  fill-column 100)
#+end_src

The file extension =.cl= is sometimes used.
#+begin_src emacs-lisp
(push '("\\.cl\\'" . lisp-mode) auto-mode-alist)
#+end_src

#+begin_src emacs-lisp
(add-hook 'lisp-mode-hook #'lisp-mode-common-hook)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'lisp-mode-hook
  rotate-text-local-symbols
  '(("t" "nil")
    ("defvar" "defparameter" "defconstant")
    ("when" "unless"))
  rotate-text-local-patterns
  '(("#[+-]\\(\\sw\\|\\s_\\)*" *lisp-rotate-text-flip-feature-test)))
#+end_src

#+begin_src emacs-lisp
(defun *lisp-rotate-text-flip-feature-test (original arg)
  (unless (zerop (mod arg 2))
    (aset original 1 (if (eq (aref original 1) ?+) ?- ?+)))
  original)
#+end_src

*** Sly
#+begin_src emacs-lisp
(setq sly-default-lisp 'sbcl
      sly-common-lisp-style-default 'modern)
#+end_src

#+begin_src emacs-lisp
(after! sly
  (push! sly-lisp-implementations
         '(clisp ("clisp"))
         '(cmucl ("cmucl"))
         '(sbcl ("sbcl" "--inferior") :coding-system utf-8-unix)))
#+end_src

#+begin_src emacs-lisp
(map! :after sly
      :map lisp-mode-map
      :localleader
      :desc "Evaluate defun" "e d" #'sly-eval-defun)
#+end_src

#+begin_src emacs-lisp
(map! :after sly
      :map sly-mrepl-mode-map
      "C-<down>" #'sly-mrepl-next-input-or-button
      "C-<up>" #'sly-mrepl-previous-input-or-button
      :i "<down>" #'sly-mrepl-next-input-or-button
      :i "<up>" #'sly-mrepl-previous-input-or-button
      "<mouse-2>" #'sly-mrepl-insert-input)
#+end_src

*** Smartparens
#+begin_src emacs-lisp
(defun *sp-common-lisp-skip-match-h (delim beg _end)
  "Like `sp--elisp-skip-match', but for `lisp-mode'."
  (when (and delim (> beg 1))
    (save-excursion
      (goto-char beg)
      (save-match-data
        (and (sp--looking-back "\\\\" 1 t)
             (not (sp--looking-back "#\\\\\\\\" 3 t)))))))
#+end_src

#+begin_src emacs-lisp
(after! smartparens
  (cl-dolist (pair '(("(" . ")") ("[" . "]") ("{" . "}")))
    (sp-local-pair '(lisp-mode sly-mrepl-mode)
                   (car pair) (cdr pair)
                   :unless '(:add sp-char-escaped-p)
                   :skip-match #'*sp-common-lisp-skip-match-h)))
#+end_src

** Elixir
#+begin_src emacs-lisp
(defvaralias 'elixir-basic-offset      'standard-indent)
(defvaralias 'elixir-smie-indent-basic 'standard-indent)
#+end_src

The Elixir formatter =mix format= sadly has very strong conventions. I might be
able to work around this when I implement my own =fmt-mix= functions, using
~doom/retab~ or =unexpand= after formatting, but for now we just set
~standard-indent~ to =2=.
#+begin_src emacs-lisp
(setq-hook! 'elixir-mode-hook standard-indent 2)
#+end_src

#+begin_src emacs-lisp
(set-popup-rule! "^\\*Alchemist-IEx\\*$"
  :size 0.3 :vslot 2 :ttl nil :quit 'current)
#+end_src

Why did I do this again?
#+begin_src emacs-lisp
(after! alchemist
  (setq +eval-repls (assq-delete-all 'alchemist-mode +eval-repls)))
#+end_src

#+begin_src emacs-lisp
(map! :after alchemist
      :map alchemist-mode-map
      :localleader
      "a" 'alchemist-mode-keymap
      "i" #'alchemist-iex-run
      "I" #'alchemist-iex-project-run
      "M-r" #'alchemist-test-toggle-test-report-display)

(which-key-add-major-mode-key-based-replacements 'elixir-mode
  "C-c   a" "alchemist"
  "SPC m a" "alchemist"

  "C-c   a c" "compile"
  "C-c   a e" "execute"
  "C-c   a f" "info"
  "C-c   a h" "help"
  "C-c   a i" "iex"
  "C-c   a m" "mix"
  "C-c   a o" "macroexpand"
  "C-c   a X" "hex"
  "C-c   a p" "project"
  "C-c   a v" "eval"
  "SPC m a X" "hex"
  "SPC m a c" "compile"
  "SPC m a e" "execute"
  "SPC m a f" "info"
  "SPC m a h" "help"
  "SPC m a i" "iex"
  "SPC m a m" "mix"
  "SPC m a o" "macroexpand"
  "SPC m a p" "project"
  "SPC m a v" "eval")
#+end_src

** Emacs Lisp :Lisp:
Much GNU code has embedded tabs which are supposed to display as eight spaces.
For consistency, the ~tab-width~ in all Elisp modes is set to eight.
#+begin_src emacs-lisp
(setq-hook! '(emacs-lisp-mode-hook lisp-interaction-mode-hook)
  tab-width 8)
#+end_src

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook       #'lisp-mode-common-hook)
(add-hook 'lisp-interaction-mode-hook #'lisp-mode-common-hook)
;; MAYBE: Add `ielm-mode-hook'.
#+end_src

#+begin_src emacs-lisp
(after! elisp-mode
  (set-keymap-parent lisp-interaction-mode-map emacs-lisp-mode-map))
#+end_src

*** Evaluation
#+begin_src emacs-lisp
(defun *eval/buffer-and-replace ()
  (interactive)
  (+eval/region-and-replace (point-min) (point-max))
  (let ((result (eval-buffer)))
    (kill-region (point-min) (point-max))
    (insert result)))

(defun *eval/sexp-and-replace ()
  (interactive)
  (let* ((beg (progn (backward-sexp 1) (point)))
         (end (progn (forward-sexp  1) (point))))
    (+eval/region-and-replace beg end)))

(map! :after elisp-mode
      :map emacs-lisp-mode-map
      :localleader :prefix "e"
      "B" #'*eval/buffer-and-replace
      "E" #'*eval/sexp-and-replace
      "R" #'+eval/region-and-replace)
#+end_src

#+begin_src emacs-lisp
(defadvice! *pp-eval-expression-prefix-arg-a (expression &optional arg)
  "Make `pp-eval-expression' with prefix argument insert the result."
  :override #'pp-eval-expression
  (interactive
   (list (read--expression "Eval: ") current-prefix-arg))
  (message "Evaluating...")
  (let ((result (eval expression lexical-binding)))
    (values--store-value result)
    (if (null arg)
        (pp-display-expression result "*Pp Eval Output*")
      (princ result (current-buffer))
      (message "Inserted into %s buffer" (buffer-name)))))
#+end_src

*** Macro Expansion
#+begin_src emacs-lisp
(defun *elisp-macroexpand-last-sexp ()
  (interactive)
  (when (and (bound-and-true-p evil-mode)
             (not evil-move-beyond-eol)
             (or (evil-normal-state-p) (evil-motion-state-p))
             (not (or (eobp) (eolp))))
    (forward-char))
  (backward-sexp)
  (emacs-lisp-macroexpand)
  (forward-sexp))

(map! :after elisp-mode
      :map emacs-lisp-mode-map
      :localleader
      "x" #'*elisp-macroexpand-last-sexp)
#+end_src

#+begin_src emacs-lisp
(map! :after macrostep
      :map macrostep-keymap
      :n "c" #'macrostep-collapse)
#+end_src

*** Smartparens
#+begin_src emacs-lisp
(after! smartparens
  (sp-local-pair '(emacs-lisp-mode lisp-interaction-mode ielm-mode)
                 "\\\\(" "\\\\)"
                 :actions '(insert wrap autoskip navigate)
                 :when '(sp-in-string-p))
  (cl-dolist (pair '(("(" . ")") ("[" . "]") ("{" . "}")))
    (sp-local-pair '(emacs-lisp-mode lisp-interaction-mode ielm-mode)
                   (car pair) (cdr pair)
                   :unless '(:add sp-char-escaped-p)
                   :skip-match #'sp--elisp-skip-match)))
#+end_src

*** WAIT Fix Path in Elisp Module Header ([[doom-repo:pull/3684][#3684]])
This fix has been removed because my PR has been merged.
#+begin_src emacs-lisp :tangle no
(defadvice! *file-templates-short-path-in-doomdir-a (path)
  :filter-return #'+file-templates-get-short-path
  (if (and (file-name-absolute-p path)
           (file-in-directory-p path doom-private-dir))
      (file-relative-name path doom-private-dir)
    path))
#+end_src

** Emacs Lisp Data :Lisp:Data:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle no
:END:
This is an idea from the [[https://lists.gnu.org/archive/html/emacs-devel/2019-10/msg00736.html][emacs-devel]] mailing list.

Maybe ~def-project-mode!~?
#+begin_src emacs-lisp
(define-derived-mode emacs-lisp-data-mode prog-mode "Emacs-Lisp-Data"
  "Major mode for buffers holding data written in Emacs Lisp syntax."
  :group 'lisp
  (lisp-mode-variables nil nil 'elisp)
  (setq-local electric-quote-string t)
  (setq imenu-case-fold-search nil)
  (if (boundp 'electric-pair-text-pairs)
      (setq-local electric-pair-text-pairs
                  (append '((?\` . ?\') (?‘ . ?’))
                          electric-pair-text-pairs))
    (add-hook 'electric-pair-mode-hook #'emacs-lisp-set-electric-text-pairs))

  )
#+end_src

#+begin_src emacs-lisp
(defun elisp-data--form-quoted-p (pos)
  (save-excursion
    (or
     (not ;; Inside eval form.
      (cl-dolist (ppos (nth 9 (syntax-ppss pos)))
        (goto-char ppos)
        (when (looking-at-p "(eval") (cl-return t))))
     (elisp--form-quoted-p pos))))
#+end_src

#+begin_src emacs-lisp
(push! auto-mode-alist
       '("\\`\\.#" . emacs-lisp-data-mode)
       '("\\`\\.dir-locals\\.el\\'" . emacs-lisp-data-mode)
       (cons (lambda (fname) (string= dir-locals-file fname))
             'emacs-lisp-data-mode))
#+end_src

** Fennel :Lisp:Lua:
#+begin_src emacs-lisp
(add-hook 'fennel-mode-hook #'lisp-mode-common-hook)
#+end_src

** Haskell
#+begin_src emacs-lisp
(setq-hook! 'haskell-mode-hook standard-indent 2)
#+end_src

These bindings are used by many modes with an inferior REPL.
#+begin_src emacs-lisp
(map! :after haskell-mode
      :map haskell-mode-map
      "C-c C-c" #'haskell-process-load-file
      "C-c C-k" #'haskell-process-load-file
      "C-c C-z" #'haskell-interactive-switch)
#+end_src

Flycheck raises a "Suspicious State" error when the linter exits with a nonzero
error code. Using =--no-exit-code= prevents this.
#+begin_src emacs-lisp
(setq flycheck-hlint-args '("--no-exit-code"))
#+end_src

#+begin_src emacs-lisp
(after! (dante flycheck)
  (flycheck-add-next-checker 'haskell-dante '(warning . haskell-hlint)))
#+end_src

** HTML/CSS
#+begin_src emacs-lisp
(defvaralias 'sgml-basic-offset 'standard-indent)
(defvaralias 'css-indent-offset 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! '(sgml-mode-hook html-mode-hook mhtml-mode-hook css-mode-hook web-mode-hook)
  standard-indent 2)
#+end_src

#+begin_src emacs-lisp
(setq web-mode-attr-indent-offset   2)
(setq web-mode-markup-indent-offset 2)
#+end_src

Add HTML folding rules to ~web-mode~.
#+begin_src emacs-lisp
(after! hideshow
  (assq-delete-all 'web-mode hs-special-modes-alist)
  (push! hs-special-modes-alist
         '(web-mode
           "{\\|<!--\\|<[^/>?][^>]*[^/]>"
           "}\\|-->\\|</[^>]*[^/]>"
           "/[*/]\\|<!--"
           web-mode-forward-sexp
           nil)))
#+end_src

** Hy :Lisp:Python:
#+begin_src emacs-lisp
(add-hook 'hy-mode-hook #'lisp-mode-common-hook)
#+end_src

** JavaScript
#+begin_src emacs-lisp
(defvaralias 'js-indent-level 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'js-mode-hook
  standard-indent 2
  tab-width 2
  indent-tabs-mode t)
#+end_src

** LaTeX
#+begin_src emacs-lisp
(defvaralias 'LaTeX-indent-level 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'LaTeX-mode-hook
  fill-column 100
  rotate-text-local-symbols '(("iftrue" "iffalse"))
  standard-indent 2
  tab-width 2
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(setq tex-fontify-script nil)
(setq font-latex-fontify-script nil)
(setq-default TeX-output-dir "build")
#+end_src

#+begin_src emacs-lisp
(after! latex
  (push "lstlisting" LaTeX-verbatim-environments)
  (push "lstlisting" LaTeX-verbatim-macros-with-braces)
  (push "lstlisting" LaTeX-verbatim-macros-with-delims))
#+end_src

#+begin_src emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'latex-mode
    "C-c C-p"     '("preview" . "Inline formula preview")
    "C-c C-p C-c" "clear"
    "C-c C-o"     "fold"
    "C-c C-q"     "fill"
    "C-c C-t"     "toggle"))
#+end_src

Let Smartparens handle insertion of =$=.
#+begin_src emacs-lisp
(map! :after tex-mode :map LaTeX-mode-map "$" nil)
#+end_src

Some Smartparens settings for LaTeX pairs.
Letting Smartparens handle these works best in my experience.
#+begin_src emacs-lisp
(after! smartparens
  (sp-with-modes '(tex-mode plain-tex-mode latex-mode)
    (sp-local-pair "\"`" "\"'"          ; German quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\"<" "\">"          ; French quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\\\\(" "\\\\)" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-local-pair "\\[" "\\]" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))))
#+end_src

Using =dvipng= is faster than =png= and is even recommended
in the [[info:preview-latex#Requirements][manual]] of =preview-latex=.
#+begin_src emacs-lisp :tangle no
(when (executable-find "dvipng") (setq preview-image-type 'dvipng))
#+end_src

#+begin_src emacs-lisp :tangle no
(set-popup-rule! "^\\*Latex Preview Pane")
#+end_src

*** NOTE Electric Env Pairs
Maybe add ~latex-electric-env-pair-mode~ to ~LaTeX-mode-hook~.

** Lisp
A common hook for all lisp modes.
#+begin_src emacs-lisp
(defvar lisp-mode-common-hook nil
  "Hook called by all Lisp modes for common initialization.")

(defun lisp-mode-common-hook (&rest args)
  "Run all functions in `lisp-mode-common-hook' with ARGS."
  (apply #'run-hook-with-args 'lisp-mode-common-hook args))
#+end_src

Improve the comment insertion of ~comment-dwim~.
#+begin_src emacs-lisp
(setq-hook! 'lisp-mode-common-hook
  comment-start-skip ";+\\s-*")
#+end_src

#+begin_src emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'lisp-mode-common-hook
    +fmt-formatter #'indent-region))
#+end_src

** Lua
Doom has already set a value for ~lua-indent-level~, so we have to unset it.
#+begin_src emacs-lisp
(makunbound 'lua-indent-level)
(defvaralias 'lua-indent-level 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'lua-mode-hook
  standard-indent 2
  tab-width 2
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(setq company-lua-interpreter 'lua53)
#+end_src

*** Indentation in Comments
Doom advises ~newline-and-indent~ to continue comments using the value of
~comment-line-break-function~. The standard value is ~comment-indent-new-line~,
which is broken in Lua's multiline comments.
#+begin_src emacs-lisp
(defun *lua-comment-indent-new-line (&optional soft)
  "Break line at point and indent, continuing a series of line comments."
  (interactive)
  (if (or (not (lua-comment-or-string-p))
          (lua-string-p)
          (not (save-excursion
                 (goto-char (lua-comment-or-string-start-pos))
                 (looking-at-p "--\\[=*\\["))))
      (comment-indent-new-line soft)
    (delete-horizontal-space t)
    (newline nil t)
    (indent-according-to-mode)))
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'lua-mode-hook
  comment-line-break-function #'*lua-comment-indent-new-line)
#+end_src

*** NOTE Comment deletion broken
The advice ~+default--delete-backward-char-a~ to ~backward-delete-char~ behaves
weirdly when deleting line comments inside of a multiline comment. I have not
yet found a fix for this.

** MoonScript :Lua:
Consolidate indentation.
#+begin_src emacs-lisp
(defvaralias 'moonscript-indent-offset 'standard-indent)
#+end_src

We are currently limited by ~moonscript-indent-line~, which doesn’t
respect ~indent-tabs-mode~.
#+begin_src emacs-lisp
(setq-hook! 'moonscript-mode-hook
  standard-indent 2
  tab-width 8
  indent-tabs-mode nil)
#+end_src

Doom Emacs, annoyingly, sets ~moonscript-indent-offset~ to ~tab-width~ by default.
#+begin_src emacs-lisp
(after! moonscript
  (remove-hook 'moonscript-mode-hook
               #'doom--setq-moonscript-indent-offset-for-moonscript-mode-h))
#+end_src

*** TODO Test this advice for indenting with tabs.
This might fix the issue with ~moonscript-indent-line~.
This should not be used with =Janfel/moonscript-mode=.
#+begin_src emacs-lisp :tangle no
(defadvice! *moonscript--run-untabified-a (orig-fn &rest args)
  :around '(moonscript-indent-line moonscript-indent-level)
  (if (not indent-tabs-mode)
      (apply orig-fn args)
    (let (indent-tabs-mode)
      (untabify (line-beginning-position) (line-end-position))
      (apply orig-fn args)
      (tabify (line-beginning-position)
              (save-excursion (back-to-indentation) (point))))))
#+end_src

** Pascal
#+begin_src emacs-lisp
(defvaralias 'pascal-indent-level  'standard-indent)
(defvaralias 'pascal-case-indent   'standard-indent)
(defvaralias 'opascal-indent-level 'standard-indent)
(defvaralias 'opascal-case-indent  'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! '(pascal-mode-hook opascal-mode-hook)
  standard-indent 3
  tab-width 3
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(setq +fmt-ptop-config-file (expand-file-name "pascal/ptop.cfg" XDG-CONFIG-HOME))
#+end_src

We have to remove ~company-capf~ from ~company-backends~, because completion
would be unusable otherwise.
#+begin_src emacs-lisp
(when (featurep! :completion company)
  (setq-hook! '(pascal-mode-hook opascal-mode-hook)
    company-backends (remq 'company-capf company-backends)))
#+end_src

** Perl
#+begin_src emacs-lisp
(defvaralias 'perl-indent-level  'standard-indent)
(defvaralias 'cperl-indent-level 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! '(perl-mode-hook cperl-mode-hook)
  indent-tabs-mode t)
#+end_src

** PHP
This allows me to not load the entire =:lang/php= module.
#+begin_src emacs-lisp
(unless (featurep! :lang php) (use-package! php-mode :defer t))
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'php-mode-hook
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(when (and (featurep! :editor fmt) (not (featurep! :lang php)))
  (setq-hook! 'php-mode-hook
    +fmt-formatter #'prettier-format-region))
#+end_src

** Python
#+begin_src emacs-lisp
(defvaralias 'python-indent-offset 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'python-mode-hook
  indent-tabs-mode nil)
#+end_src

#+begin_src emacs-lisp
(when (sys-feature-p 'black/tabs)
  (defadvice! *fmt-black-use-tabs-a (args)
    :filter-return #'+fmt-black-compute-args
    (if indent-tabs-mode (cons "--use-tabs" args) args)))
#+end_src

#+begin_src emacs-lisp
(after! which-key
  (which-key-add-major-mode-key-based-replacements 'python-mode
    "C-c C-p" "pipenv"
    "C-c C-t" "skeleton"))
#+end_src

*** Company Jedi
[[https://jedi.readthedocs.io/en/latest/][Jedi]] gives the best (non LSP) autocompletion for python.
[[https://github.com/syohex/emacs-company-jedi][=company-jedi=]] is a backend for =company= that interfaces with Jedi.
This adds =company-jedi= to =company-backends= in Python buffers.
The package will load when =company-jedi= is invoked by =company=.
#+begin_src emacs-lisp
(use-package! company-jedi
  :when (featurep! :completion company)
  :after company
  :commands company-jedi
  :init (set-company-backend! 'python-mode 'company-jedi))
#+end_src

**** NOTE Replace this by Doom’s choice of anaconda-mode?
It seems that =anaconda-mode= is no longer actively supported.

*** _Backup
:PROPERTIES:
:header-args:emacs-lisp+: :tangle no
:END:
Use system =mspyls= for =lsp-python-ms=.
#+begin_src emacs-lisp :tangle no
(when (featurep! :lang python +lsp)
  (after! lsp-python-ms
    (setq lsp-python-ms-dir "/usr/lib/microsoft-python-language-server"
          lsp-python-ms-executable "/usr/bin/mspyls")))
#+end_src

** Rust
#+begin_src emacs-lisp
(defvaralias 'rustic-indent-offset 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! '(rustic-mode-hook rustic-macro-expansion-mode-hook)
  indent-tabs-mode t)
#+end_src

#+begin_src emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! '(rustic-mode-hook rustic-macro-expansion-mode-hook)
    +fmt-formatter #'rustic-format-buffer))
#+end_src

This is currently not working because the variable has been removed.
#+begin_src emacs-lisp :tangle no
(after! rustic
  (when (boundp 'rustic-format-warning-buffer-name)
    (set-popup-rule! (rx string-start (literal rustic-format-warning-buffer-name)))))
#+end_src

#+begin_src emacs-lisp
(defadvice! *rustic--rustfmt-respect-indent-tabs-mode-a (orig-fn &rest args)
  "Make `rustic-format-buffer' respect `indent-tabs-mode'."
  :around #'rustic-format-buffer
  (let ((rustic-rustfmt-config-alist
         (cons (cons 'hard_tabs indent-tabs-mode)
               rustic-rustfmt-config-alist)))
    (apply orig-fn args)))
#+end_src

*** LSP
Make ~lsp-rust~ respect the =CARGO_HOME= and =RUSTUP_HOME= environment
variables.
#+begin_src emacs-lisp
(defconst CARGO-HOME
  (thread-first (getenv "CARGO_HOME")
    (string-or "~/.cargo/")
    (file-name-as-directory)
    (expand-file-name)))

(defconst RUSTUP-HOME
  (thread-first (getenv "RUSTUP_HOME")
    (string-or "~/.rustup/")
    (file-name-as-directory)
    (expand-file-name)))

(setq lsp-rust-library-directories
      (list (expand-file-name "registry/src/" CARGO-HOME)
            (expand-file-name "toolchains/" RUSTUP-HOME)))
#+end_src

The program [[https://github.com/rust-analyzer/rust-analyzer][rust-analyzer]] is an experimental language server and is to become
the successor to RLS. It supports inlay hints for automatically annotating
variables with their inferred types. It is the default for =rustic-mode=.
#+begin_src emacs-lisp
(setq lsp-rust-analyzer-server-display-inlay-hints t)
#+end_src

** Scheme :Lisp:
#+begin_src emacs-lisp
(add-hook 'scheme-mode-hook #'lisp-mode-common-hook)
#+end_src

*** Geiser
Make =geiser= read init files from ~doom-private-dir~ instead of ~$HOME~. This
does not need an ~(after! geiser)~ block because ~geiser-active-implementations~
is currently filled out in the autoloads file.
#+begin_src emacs-lisp
(let ((config-dir (expand-file-name "geiser/" doom-private-dir)))
  (cl-dolist (s geiser-active-implementations)
    (set (intern (format "geiser-%s-init-file" s))
         (expand-file-name (format "init-%s.scm" s) config-dir))))
#+end_src

*** Geiser Chicken
As stated in the [[https://gitlab.com/emacs-geiser/chicken][=geiser-chicken=]] repository, additional steps are needed to
fully support Chicken Scheme. See [[https://wiki.call-cc.org/eggref/5/chicken-doc]]
for more information about the =chicken-doc= egg.
#+begin_src sh
chicken-install -s apropos chicken-doc srfi-18 srfi-1
if [ ! -d "$CHICKEN_DOC_REPOSITORY" ]; then
	cd "$(csi -R chicken.platform -p '(chicken-home)')"
	curl https://3e8.org/pub/chicken-doc/chicken-doc-repo-5.tgz | sudo tar zx
	export CHICKEN_DOC_REPOSITORY="$PWD/chicken-doc/"
fi
#+end_src

On Arch, the [[https://www.call-cc.org/][Chicken Scheme]] binaries are called =chicken-csi= and =chicken-csc=.
#+begin_src emacs-lisp
(when (and IS-LINUX (executable-find "chicken-csi"))
  (setq geiser-chicken-binary "chicken-csi"))
#+end_src

** Shell
#+begin_src emacs-lisp
(defvaralias 'sh-basic-offset 'standard-indent)
#+end_src

#+begin_src emacs-lisp
(setq-hook! 'sh-mode-hook
  indent-tabs-mode t)
#+end_src

Fix indentation of =case= statements.
#+begin_src emacs-lisp
(after! smie
  (setf (alist-get 'sh-mode smie-config)
        '((0 :after "in" 4))))
#+end_src

#+begin_src emacs-lisp
(set-file-template! "\\.sh\\'"
  :trigger "__sh"
  :mode 'sh-mode)
#+end_src

** XML
#+begin_src emacs-lisp
(setq-hook! 'nxml-mode-hook
  standard-indent 2
  tab-width 8
  indent-tabs-mode nil)
#+end_src

#+begin_src emacs-lisp
(defadvice! *nxml--parameter-soft-not-being-optional-a (&optional soft)
  "Make the parameter SOFT optional to follow the spec of `comment-line-break-function'."
  :filter-args #'nxml-newline-and-indent
  (list soft))
#+end_src

Make the indentation inside of comments respect ~nxml-child-indent~.
#+begin_src emacs-lisp
(defadvice! *nxml--indent-correctly-inside-comments-a
  (orig-fn pos open-delim close-delim)
  :around #'nxml-compute-indent-in-delimited-token
  (let ((indent (funcall orig-fn pos open-delim close-delim)))
    (when (and (string= "<!--" open-delim) (string= "-->" close-delim)
               (progn (goto-char xmltok-start) (looking-at-p "<!--[[:blank:]]*$"))
               (progn (goto-char pos)
                      (back-to-indentation)
                      (not (looking-at-p "-->"))))
      (goto-char xmltok-start)
      (setq indent (+ (current-column) nxml-child-indent)))
    indent))
#+end_src

#+begin_src emacs-lisp
(after! nxml-mode
  (modify-syntax-entry ?\" "\"" nxml-mode-syntax-table)
  (modify-syntax-entry ?<  "(>" nxml-mode-syntax-table)
  (modify-syntax-entry ?>  ")<" nxml-mode-syntax-table))
#+end_src

Disable ~smartparens-mode~ because it it kind of useless in ~nxml-mode~.
#+begin_src emacs-lisp
(add-hook 'nxml-mode-hook #'turn-off-smartparens-mode)
#+end_src

#+begin_src emacs-lisp
(after! smartparens
  (sp-with-modes '(nxml-mode)
    (sp-local-pair "<" ">" :actions nil)
    (sp-local-pair "'" "'" :actions nil)
    (sp-local-pair "\"" "\"" :unless '(:rem sp-point-after-word-p))))
#+end_src

Replace the original ~nxml-mode~ rules with ones that aren’t broken.
#+begin_src emacs-lisp
(after! hideshow
  (assq-delete-all 'nxml-mode hs-special-modes-alist)
  (push! hs-special-modes-alist
         '(nxml-mode
           "<!--\\|<[^/>?][^>]*[^/]>"
           "-->\\|</[^>]*[^/]>"
           "<!--"
           sgml-skip-tag-forward
           nil)))
#+end_src

#+begin_src emacs-lisp
(setq lsp-xml-server-work-dir (expand-file-name "lsp4xml/" XDG-CACHE-HOME))
#+end_src

* Keybindings
** Translations
Translate =C-ä= and =C-ö= for use with the Neo2 layout.
#+begin_src emacs-lisp
(map! :map local-function-key-map
      "C-ö" (kbd "C-x")
      "C-ä" (kbd "C-c"))
#+end_src

#+begin_src emacs-lisp
(map! :map local-function-key-map "−" "-")
#+end_src

** Fixes for =feature/pgtk= :28:
Un-hyperify my Mod-3 keys on =pgtk=.
#+begin_src emacs-lisp
(map! :when (and EMACS28+ (eq window-system 'pgtk))
      :map input-decode-map
      "H-<up>"        "<up>"
      "H-<down>"      "<down>"
      "H-<left>"      "<left>"
      "H-<right>"     "<right>"
      "H-<home>"      "<home>"
      "H-<end>"       "<end>"
      "H-<backspace>" "<backspace>"
      "H-<delete>"    "<delete>"
      "H-<prior>"     "<prior>"
      "H-<next>"      "<next>"
      "H-<escape>"    "<escape>")
#+end_src

** Well Known Bindings
Use well known bindings such as =C-c=, =C-v= in =insert-state=.
#+begin_src emacs-lisp
(map! :i "C-S-c" #'kill-ring-save
      :i "C-S-x" #'kill-region
      :i "C-v"   #'yank
      :i "C-S-v" #'yank-pop
      :i "C-s"   #'save-buffer)
#+end_src

** Leader Extensions
It is handy to have ~negative-argument~ on a binding
similar to that of ~universal-argument~.
#+begin_src emacs-lisp
(map! :leader
      :desc "Negative Argument" "-" #'negative-argument)
#+end_src

Bind ~shell-command~ in a similar way to =M-x= and =M-;=.
#+begin_src emacs-lisp
(map! :leader
      :desc "Shell command" "!" #'shell-command
      :desc "Async command" "&" #'async-shell-command)
#+end_src

*** Buffer Map
#+begin_src emacs-lisp
(map! :map doom-leader-buffer-map
      :desc "Rename buffer" "R" #'rename-buffer)
#+end_src

*** Debug Map
Bind a prefix for edebug commands.
#+begin_src emacs-lisp
(map! :after edebug :leader :desc "debug" "d" global-edebug-map)
#+end_src

*** File Map
Bind a key for switching between two related files.
#+begin_src emacs-lisp
(map! :map doom-leader-file-map
      :desc "Find other file" "o" #'ff-find-other-file)
#+end_src

*** Git Map
Bind mnemonics for =git add=.
#+begin_src emacs-lisp
(map! :map doom-leader-git-map
      (:when (featurep! :ui vc-gutter)
       :desc "Git add hunk" "a" #'git-gutter:stage-hunk
       :desc "Diff hunk"    "d" #'git-gutter:popup-hunk)
      (:when (featurep! :tools magit)
       :desc "Git add file" "A" #'magit-stage-file))
#+end_src

*** Set Map
Bind a prefix for setting things to values.
#+begin_src emacs-lisp
(map! :leader :prefix ("S" . "set")
      "f" #'set-frame-font
      "F" #'menu-set-font
      "i" #'doom/set-indent-width
      "o" #'doom/set-frame-opacity
      "t" #'load-theme
      "v" #'set-variable)
#+end_src

*** Toggle Map
#+begin_src emacs-lisp
(map! :leader :prefix "t"
      :desc "Whitespace" "<SPC>" #'whitespace-mode
      (:when EMACS27+
       :desc "Fill column indicator" "c" #'display-fill-column-indicator-mode)
      (:when (fboundp #'highlight-indent-guides-mode)
       :desc "Indent guides" "G" #'highlight-indent-guides-mode)
      :desc "Variable width fonts" "v" #'variable-pitch-mode
      :desc "Hard line wrapping" "W" #'auto-fill-mode)
#+end_src

** Help Map
#+begin_src emacs-lisp
(map! :map help-map
      ;; Doom replaces this binding with `doom/help-news'.
      "n" #'view-emacs-news)
#+end_src

** _Backup
:PROPERTIES:
:header-args:emacs-lisp+: :tangle no
:END:
Some stuff I don't use anymore.
#+begin_src emacs-lisp
(map! :leader :desc "List buffers" "b L" #'list-buffers)
(map! "<mouse-8>" #'backward-page
      "<mouse-9>" #'forward-page)
(map! :m "C-e" nil)
#+end_src
