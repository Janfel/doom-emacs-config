#+TITLE: Doom Emacs Configuration
#+DESCRIPTION: Doom Emacs configuration of Jan Felix Langenbach
#+AUTHOR: Jan Felix Langenbach
#+EMAIL: o.hase3@gmail.com
#+PROPERTY: header-args:emacs-lisp :tangle yes :lexical yes
#+STARTUP: fold

* Introduction
These are some useful links to manuals and other peoples configs.

+ [[https://www.gnu.org/software/emacs/manual][Emacs Manual]]
+ [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]]
+ [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
+ [[https://github.com/MatthewZMD/.emacs.d][M-Emacs]]
+ [[https://github.com/poncie/.emacs.d][Poncie's Config]]
+ [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Config]]

** Header
This header comment ensures that everything in this file is lexically scoped.
#+BEGIN_SRC emacs-lisp
;;; doom/config.el -*- lexical-binding: t; -*-
#+END_SRC

** Requires
*** [[https://github.com/magnars/dash.el][dash.el]]
A modern list library inspired by Clojure.
#+BEGIN_SRC emacs-lisp
(require 'dash)
#+END_SRC

*** [[https://github.com/purcell/reformatter.el][reformatter.el]]
A library for creating formatting functions.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :editor fmt)
  (require 'reformatter))
#+END_SRC

* Definitions
** Functions and Macros
#+BEGIN_SRC emacs-lisp
(defun string-or (&rest strings)
  "Return the first non-nil and non-empty string in STRINGS."
  (cl-dolist (s strings)
    (when (and s (not (string-empty-p s)))
      (cl-return s))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun sys-feature-p (feature)
  "Return t if FEATURE is available on this system."
  (memq feature SYS-FEATURES))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro push! (place &rest values)
  "Push VALUES into PLACE."
  `(setf ,place (nconc (list ,@values) ,place)))
#+END_SRC

** Commands
#+BEGIN_SRC emacs-lisp
(defun comments-to-column (&optional column)
  "Move any end-of-line comments to COLUMN or `comment-column'."
  (interactive "*")
  (let ((beg (if (doom-region-active-p)
                 (doom-region-beginning)
               (line-beginning-position)))
        (end (if (doom-region-active-p)
                 (doom-region-end)
               (line-end-position)))
        (column (or column comment-column)))
    (save-excursion
      (goto-char beg)
      (while (< (point) end)
        (beginning-of-line)
        (when (looking-at ".*\\s-\\(\\s<\\)")
          ;; Go to the last comment starter preceded by whitespace.
          (goto-char (match-beginning 1))
          ;; Delete all whitespace before point.
          (delete-char (abs (skip-syntax-backward "\\s-")))
          (indent-to column 1))
        (forward-line 1)))))
#+END_SRC

** Constants
*** System
#+BEGIN_SRC emacs-lisp
(defconst SYSTEM
  (let ((sysname (system-name)))
    (cond ((string= sysname "PhantomJFL") 'Phantom)
          ((string= sysname "TeslaJFL")   'Tesla)
          (t 'other)))
  "Which system are we running on?")
#+END_SRC

I redefine the operating system constants of Doom Emacs to give them docstrings.
#+BEGIN_SRC emacs-lisp
(defconst IS-LINUX IS-LINUX
  "Are we on a Linux system?")

(defconst IS-MAC IS-MAC
  "Are we on a Mac?")

(defconst IS-WINDOWS IS-WINDOWS
  "Are we on a Windows system?")

(defconst IS-BSD IS-BSD
  "Are we on a BSD system?")
#+END_SRC

*** Environment
These constants allow me to use the correct directories everywhere,
without lengthy invocation of =getenv=.
#+BEGIN_SRC emacs-lisp
(defconst XDG-DATA-HOME
  (-> (getenv "XDG_DATA_HOME")
      (string-or "~/.local/share/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_DATA_HOME where programs store data.")

(defconst XDG-CONFIG-HOME
  (-> (getenv "XDG_CONFIG_HOME")
      (string-or "~/.config/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CONFIG_HOME where programs place configuration files.")

(defconst XDG-CACHE-HOME
  (-> (getenv "XDG_CACHE_HOME")
      (string-or "~/.cache/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CACHE_HOME where programs place cache files.")

(defconst SYS-FEATURES
  (mapcar #'intern (-> (getenv "SYS_FEATURES")
                       (or "") (split-string ":")))
  "A list of symbols which represent system features.")
#+END_SRC

* Emacs
** Core
Don’t untabify when deleting a tab character.
#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC

Make the block cursor stretch to highlight tab characters.
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

Make the output buffer of ~shell-command~ a popup buffer.
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "^\\*Shell Command Output\\*$" :quit t)
#+END_SRC

** Custom.el
Move the ~customize~ blocks into =custom.el=.
#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" doom-private-dir))
#+END_SRC
** Fill Column Indicator
#+BEGIN_SRC emacs-lisp
(when EMACS27+
  (add-hook! '(prog-mode-hook text-mode-hook)
             #'display-fill-column-indicator-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when EMACS27+
  (defun display-fill-column-indicator-mode--turn-off ()
    (interactive)
    (display-fill-column-indicator-mode -1)))
#+END_SRC

** Hideshow
#+BEGIN_SRC emacs-lisp
(map! :after hideshow
      :map hs-minor-mode-map
      :leader :prefix ("c h" . "Hide code")
      :desc "Toggle hiding"    "h" #'hs-toggle-hiding
      :desc "Hide all"         "a" #'hs-hide-all
      :desc "Show all"         "A" #'hs-show-all
      :desc "Hide block"       "b" #'hs-hide-block
      :desc "Show block"       "B" #'hs-show-block
      :desc "Hide level"       "l" #'hs-hide-level
      :desc "Hide top comment" "c" #'hs-hide-initial-comment-block)
#+END_SRC

** Info
Treat ~info~ buffers as real buffers.
#+BEGIN_SRC emacs-lisp
(after! info (set-popup-rule! "^\\*info\\*$" :ignore))
#+END_SRC

** Visual Line Mode
#+BEGIN_SRC emacs-lisp
(defun turn-off-visual-line-mode ()
  (interactive)
  (visual-line-mode -1))
#+END_SRC

** Whitespace Mode
#+BEGIN_SRC emacs-lisp
(after! whitespace
  (setq whitespace-style
        '(face
          indentation
          lines-tail
          empty
          tabs
          tab-mark
          space-before-tab
          space-after-tab)))
#+END_SRC

* Doom
These packages are used in the ~:core~ of Doom Emacs.
That means we don't need ~featurep!~.

** Core
Don’t turn on ~whitespace-mode~ automatically.
#+BEGIN_SRC emacs-lisp
(defadvice! *doom--disable-automatic-whitespace-mode-a (&rest _)
  "Don’t turn on `whitespace-mode' on startup."
  :after #'doom-init-ui-h
  (remove-hook 'after-change-major-mode-hook
               #'doom-highlight-non-default-indentation-h))
#+END_SRC

Define these variables from =core/autoload/config.el=.
#+BEGIN_SRC emacs-lisp
(setq doom-bin-dir (concat doom-emacs-dir "bin/")
      doom-bin     (concat doom-bin-dir   "doom"))
#+END_SRC

** Helpful
Some function definitions contain tab character that are
assumed to be eight spaces wide.
#+BEGIN_SRC emacs-lisp
(after! helpful
  (setq-hook! 'helpful-mode-hook
    tab-width 8
    x-stretch-cursor nil))
#+END_SRC

** Smartparens
#+BEGIN_SRC emacs-lisp
(when (featurep! :config default +smartparens)
  (after! smartparens (show-smartparens-global-mode +1)))
#+END_SRC

*** Keybindings
Bind ~sp-raise-sexp~, which I use quite often.
#+BEGIN_SRC emacs-lisp
(map! :n "z r" #'sp-raise-sexp)
#+END_SRC

*** WAIT Closing paren deleted twice ([[https://github.com/hlissner/doom-emacs/issues/3268][#3268]])
This is currently broken, in that two closing delimiters are deleted instead of
one. When the linked issue is resolved, this fix can be removed.
#+BEGIN_SRC emacs-lisp
(when (featurep! :config default +smartparens)
  (setq sp-autodelete-pair nil))
#+END_SRC

** Which Key
These are some default keybindings that are missing a description.
#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-x"      '("global" . "Global commands")
    "C-x RET"  "locale"
    "C-x ESC"  "complex-repeat"
    "C-x 4"    "other-window"
    "C-x 5"    "other-frame"
    "C-x 6"    "two-column"
    "C-x 8"    '("unicode" . "Unicode symbols")
    "C-x @"    '("apply-modifier" . "Add a modifier to the next event")
    "C-x a"    "abbrev"
    "C-x a i"  "inverse"
    "C-x v"    "version-control"
    "C-x n"    "narrow"
    "C-x r"    "rectangle/register"
    "C-c"      '("mode-specific" . "Mode specific commands")
    "M-s"      "search"
    "M-s h"    "highlight"
    "M-g"      "goto")

  (push! which-key-replacement-alist
         '(("<up>"   . nil) . ("↑" . nil))
         '(("<down>" . nil) . ("↓" . nil))))
#+END_SRC

** WS Butler
In ~snippet-mode~, whitespace has significant meaning.
#+BEGIN_SRC emacs-lisp
(after! ws-butler
  (push 'snippet-mode ws-butler-global-exempt-modes))
#+END_SRC

* Features
** Formatting
I replace the default formatting function with my own.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor fmt)
      :nv "g =" #'+fmt:region
      :map doom-leader-code-map
      :desc "Format buffer/region" "f" #'+fmt/dwim)
#+END_SRC

** Form Feed
This mode displays instances of =^L= (form feed) as horizontal lines.
#+BEGIN_SRC emacs-lisp
(use-package! form-feed
  :hook ((prog-mode text-mode) . form-feed-mode))
#+END_SRC

*** Keybindings
Allows jumping from =^L= to =^L=.
#+BEGIN_SRC emacs-lisp
(map! "C-M-<next>"  #'forward-page
      "C-M-<prior>" #'backward-page)
#+END_SRC

** Indentation
*** Indent Guides
The package [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]] draws a line for each indentation level.
#+BEGIN_SRC emacs-lisp
(use-package! highlight-indent-guides
  ;; Maybe change this to mode-by-mode basis.
  :commands (highlight-indent-guides-mode)
  :config
  (setq highlight-indent-guides-method 'bitmap
        highlight-indent-guides-bitmap-function
        #'highlight-indent-guides--bitmap-line
        highlight-indent-guides-responsive 'top))
#+END_SRC

*** Indent Level
Indentation in Emacs is a mess currently. Each mode defines its own variables.
This consolidates indentation into one single variable.
#+BEGIN_SRC emacs-lisp
(defvar-local indent-level 4
  "Indentation level for all major-modes.")

(defvaralias 'standard-indent 'indent-level)
#+END_SRC

*** Tabs for Indentation
Disable tab insertion by default. It will be enabled manually for each mode.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+END_SRC

These functions have a tendency to insert tabs where they don’t belong.
#+BEGIN_SRC emacs-lisp
(defadvice! *emacs--disable-indent-tabs-mode-a (orig-fn &rest args)
  "Let `indent-tabs-mode' be bound to nil."
  :around '(align-areas comment-indent indent-relative)
  (let (indent-tabs-mode) (apply orig-fn args)))
#+END_SRC

** Literate Configuration
Make ~+literate-recompile-maybe-h~ compile in non-blocking subprocess.
#+BEGIN_SRC emacs-lisp
(when (featurep! :config literate)
  (defadvice! *literate--async-compilation-a (&rest _)
    "Compile config.org in a separate “doom tangle” process."
    :override #'+literate-recompile-maybe-h
    (when (and (eq major-mode 'org-mode)
               (file-in-directory-p buffer-file-name doom-private-dir))
      (message "Compiling your literate config...")
      (start-process "proc" nil (expand-file-name "doom" doom-bin-dir) "tangle"))))
#+END_SRC

* Packages
** Company
*** Quickhelp
#+BEGIN_SRC emacs-lisp
(use-package! company-quickhelp
  :when (featurep! :completion company)
  :after company
  :hook (company-mode-hook . company-quickhelp-local-mode)
  :config (setq company-quickhelp-use-propertized-text nil))
#+END_SRC

** Evil
*** Core
Evil uses Vim’s undo increments by default, which are too coarse for me.
#+BEGIN_SRC emacs-lisp
(when (featurep! :editor evil)
  ;; We can’t use `defvaralias' here, because `evil-mode' is already
  ;; running and `evil-shift-width' therefore a localized variable.
  ;;(defvaralias 'evil-shift-width 'indent-level)
  (setq evil-want-fine-undo t
        ;; This seems to be broken.
        evil-indent-convert-tabs nil))
#+END_SRC

**** Keybindings
Map the arrow keys in Evils window map.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil
      :map evil-window-map
      "<up>"      #'evil-window-up
      "<down>"    #'evil-window-down
      "<left>"    #'evil-window-left
      "<right>"   #'evil-window-right
      "S-<up>"    #'+evil/window-move-up
      "S-<down>"  #'+evil/window-move-down
      "S-<left>"  #'+evil/window-move-left
      "S-<right>" #'+evil/window-move-right
      "C-h"       nil
      "C-j"       nil
      "C-k"       nil
      "C-l"       nil)
#+END_SRC

Remap the document scroll motions to something more sensible.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil
      :m "z+" nil
      :m "z-" nil
      :m "z^" nil
      :m "z." nil
      :m "zT" #'evil-scroll-bottom-line-to-top
      :m "zB" #'evil-scroll-top-line-to-bottom
      :m "z S-<right>" #'evil-scroll-right
      :m "z S-<left>" #'evil-scroll-left)
#+END_SRC

*** Collection
I don't like my games to use Vim keys. This has to be so complicated because
Doom loads =evil-collection= manually.
#+BEGIN_SRC emacs-lisp
(when (and (featurep! :editor evil +everywhere)
           doom-interactive-p
           (not doom-reloading-p)
           (not (memq 'evil-collection doom-disabled-packages)))
  (add-transient-hook! #'+evil-collection-init
    ;; This runs right after `+evil-collection-init' is first called.
    (push! +evil-collection-disabled-list
           'tetris '2084-game 'haskell-error-mode)))
#+END_SRC

*** Numbers
Remap the ~inc-at-pt~ functions, so =z == can be used for formatting.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-numbers
      :nv "g +" #'evil-numbers/inc-at-pt
      :nv "g -" #'evil-numbers/dec-at-pt
      :v  "z +" #'evil-numbers/inc-at-pt-incremental
      :v  "z -" #'evil-numbers/dec-at-pt-incremental)
#+END_SRC

*** Snipe
Put ~evil-snipe-repeat~ on Comma and Shift-Comma.
Doesn’t seem to work due to keymap precedences.
#+BEGIN_SRC emacs-lisp :tangle no
(map! :when (featurep! :editor evil)
      :after evil
      :map evil-snipe-parent-transient-map
      "," #'evil-snipe-repeat
      "–" #'evil-snipe-repeat-reverse
      ";" nil)
#+END_SRC

*** Org
Doom Emacs changes ~org-cycle~ to skip the =subtree= stage by default when
~(featurep! :editor evil +everywhere)~.
#+BEGIN_SRC emacs-lisp
(when! (featurep! :editor evil +everywhere)
  (after! evil-org
    (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h)))
#+END_SRC

Add block jumping to =[= and =]=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-org
      :map evil-org-mode-map
      :m "[ _" #'org-previous-block
      :m "] _" #'org-next-block)
#+END_SRC

Remap =z r= and =z m= to =z O= and =z C=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-org
      :map evil-org-mode-map
      :n "z r" nil
      :n "z m" nil
      :n "z O" #'+org/show-next-fold-level
      :n "z C" #'+org/hide-next-fold-level)
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :checkers syntax)
      :after flycheck
      (:leader :prefix "c"
        (:prefix ("!" . "flycheck") "" flycheck-command-map))
      (:map flycheck-command-map
        "!" #'flycheck-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when! (featurep! :checkers syntax)
  (after! which-key
    (which-key-add-key-based-replacements
      "C-c !" "flycheck")))
#+END_SRC

** Hungry Delete
These functions delete all whitespace up to the next non-whitespace character.
#+BEGIN_SRC emacs-lisp
(use-package! hungry-delete
  :bind (("M-DEL"      . hungry-delete-backward)
         ("M-<delete>" . hungry-delete-forward)))
#+END_SRC

** Ivy
Don’t show =../= in file completion buffer.
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion ivy)
  (setq ivy-extra-directories '("./")))
#+END_SRC

*** Keybindings
Ivy should recurse into directories when pressing =RET=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :completion ivy)
      :after ivy
      :map ivy-minibuffer-map
      "<return>"   #'ivy-alt-done
      "C-<return>" #'ivy-immediate-done
      "C-l"        #'ivy-done
      "C-<up>"     #'ivy-previous-history-element
      "C-<down>"   #'ivy-next-history-element)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
(when (and (featurep! :checkers syntax)
           (featurep! :tools lsp))
  (setq lsp-prefer-flymake nil))
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
(after! magit
  (add-hook 'git-commit-setup-hook #'turn-off-flyspell)
  (setq-hook! 'git-commit-setup-hook fill-column 50))
#+END_SRC

** Spelling
*** Ispell
#+BEGIN_SRC emacs-lisp
(after! ispell
  (setq ispell-dictionary "en_US"))
#+END_SRC

*** Flyspell
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers spell)
  (remove-hook 'prog-mode-hook #'flyspell-mode))
#+END_SRC

** Tree View
*** Neotree
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :ui neotree)
      :after neotree
      :map neotree-mode-map
      :n "<tab>" #'neotree-quick-look)
#+END_SRC

*** Treemacs
** Undo Tree
When =undo-tree= is allowed to automatically save the undo history, it somehow
chokes on an empty undo list and interrupts us with constant errors.
#+BEGIN_SRC emacs-lisp
(when (featurep! :emacs undo +tree)
  (setq undo-tree-auto-save-history nil))
#+END_SRC

** VTerm
This hack removes a problematic popup rule.
#+BEGIN_SRC emacs-lisp
(when (featurep! :term vterm)
  (after! vterm
    (setq display-buffer-alist (assoc-delete-all "^vterm" display-buffer-alist))))
#+END_SRC

VTerm doesn’t recognize any keypad keys for some reason. This advice translates
the keypad keycodes into the corresponding keyboard keycodes.
#+BEGIN_SRC emacs-lisp
(when (featurep! :term vterm)
  (defadvice! *vterm--add-keypad-keys-a (args)
    "Make `vterm' recognize `<kp-*>' sequences by translating them."
    :filter-args #'vterm-send-key
    (let ((key (car args)))
      (when (string-prefix-p "<kp-" key)
        (setq key (substring key 4 -1))
        (when (> (length key) 1)
          (setq key (cond ((string= key "add"      ) "+")
                          ((string= key "subtract" ) "-")
                          ((string= key "multiply" ) "*")
                          ((string= key "divide"   ) "/")
                          ((string= key "separator") ",")
                          (t key))))
        (setf (car args) key))
      args)))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
(when! (featurep! :editor snippets)
  (after! which-key
    (which-key-add-key-based-replacements
      "C-c &" "snippet")))
#+END_SRC
* Languages
** Assembler
#+BEGIN_SRC emacs-lisp
(after! asm-mode
  (setq-hook! 'asm-mode-hook
    tab-width 8
    indent-tabs-mode t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! asm-mode
  (defadvice! *asm--add-indentation-rules-a (&rest _)
    "Add rule clauses to `asm-calculate-indentation'."
    :before-until #'asm-calculate-indentation
    (and (looking-at "section") 0)))
#+END_SRC

** BASIC
#+BEGIN_SRC emacs-lisp
(after! basic-mode
  (defvaralias 'basic-indent-offset 'indent-level)
  (setq-hook! 'basic-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'basic-format-code))
#+END_SRC

** C/C++
*** TODO Code Style
The default is =doom=.
I have yet to create my own style.
#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl"
               '("linux"
                 (indent-tabs-mode . t)
                 (c-basic-offset   . 4)
                 (tab-width        . 4)))
  (setq c-default-style
        '((java-mode . "java")
          (awk-mode  . "awk")
          ;; (other     . "k&r")
          (other     . "jfl")
          )))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl" '("linux"
                       (indent-tabs-mode . t)
                       (tab-width . 4)
                       (c-basic-offset . 4)))
  (if (listp c-default-style)
      (setf (alist-get 'other c-default-style) "jfl")
    (setq c-default-style "jfl")))
#+END_SRC


*** Arduino
#+BEGIN_SRC emacs-lisp
(after! arduino
  (setq arduino-mode-home (expand-file-name "~/src/arduino/")))
#+END_SRC

This only works with a *patched* Arduino runtime.
#+BEGIN_SRC emacs-lisp
(after! ede-arduino
  (let ((arduino-dir (expand-file-name "arduino/" XDG-DATA-HOME)))
    (when (and (sys-feature-p 'arduino/xdg) (file-directory-p arduino-dir))
      (setq ede-arduino-preferences-file
            (expand-file-name "preferences.txt" arduino-dir)))))
#+END_SRC

*** C
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! cc-mode
    (setq-hook! 'c-mode-hook
      flycheck-gcc-language-standard   "gnu18"
      flycheck-clang-language-standard "gnu18")))
#+END_SRC

*** C++
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! cc-mode
    (setq-hook! 'c++-mode-hook
      flycheck-gcc-language-standard   "gnu++17"
      flycheck-clang-language-standard "gnu++17")))
#+END_SRC

*** Meson
Major mode for the [[https://mesonbuild.com][Meson Build System]].
#+BEGIN_SRC emacs-lisp
(use-package! meson-mode :defer t)
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
(after! haskell-mode
  (setq-hook! 'haskell-mode-hook
    indent-level 2))
#+END_SRC

*** Dante
#+BEGIN_SRC emacs-lisp
(when (featurep! :lang haskell +dante)
  (add-hook 'haskell-mode-hook #'dante-mode)
  (when (featurep! :checkers syntax)
    (after! (dante flycheck)
      (flycheck-add-next-checker 'haskell-dante '(warning . haskell-hlint)))))
#+END_SRC

*** Keybindings
These bindings are used by many modes with an inferior REPL.
#+BEGIN_SRC emacs-lisp
(map! :after haskell-mode
      :map haskell-mode-map
      "C-c C-c" #'haskell-process-load-file
      "C-c C-k" #'haskell-process-load-file
      "C-c C-z" #'haskell-interactive-switch)
#+END_SRC

*** Flycheck
Flycheck raises a "Suspicious State" error when the linter exits with a nonzero
error code. Using =--no-exit-code= prevents this.
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! haskell-mode
    (add-hook 'haskell-mode-hook #'flycheck-mode)
    (setq flycheck-hlint-args '("--no-exit-code"))))
#+END_SRC

** Javascript
#+BEGIN_SRC emacs-lisp
(after! js
  (defvaralias 'js-indent-level 'indent-level)
  (setq-hook! 'js-mode-hook
    indent-level 2
    tab-width 2
    indent-tabs-mode t
    +fmt-formatter #'prettier-format-region))
#+END_SRC

** LaTeX
*** Preview
Using =dvipng= is faster than =png= and is even recommended
in the [[info:preview-latex#Requirements][manual]] of =preview-latex=.
#+BEGIN_SRC emacs-lisp
(after! preview
  (when (executable-find "dvipng") (setq preview-image-type 'dvipng)))
#+END_SRC


*** TeX
*** LaTeX
This doesn't seem to work.
#+BEGIN_SRC emacs-lisp :tangle no
(after! tex-mode
  (add-hook 'LaTeX-mode-hook #'latex-electric-env-pair-mode))
#+END_SRC

**** Which Key
#+BEGIN_SRC emacs-lisp
(after! (tex-mode which-key)
  (which-key-add-major-mode-key-based-replacements 'latex-mode
    "C-c C-p"     '("preview" . "Inline formula preview")
    "C-c C-p C-c" "clear"
    "C-c C-o"     "fold"
    "C-c C-q"     "fill"
    "C-c C-t"     "toggle"))
#+END_SRC

**** Smartparens
Let Smartparens handle insertion of =$=.
#+BEGIN_SRC emacs-lisp
(map! :after tex-mode
      :map LaTeX-mode-map
      "$" nil)
#+END_SRC

Some Smartparens settings for LaTeX pairs.
Letting Smartparens handle these works best in my experience.
#+BEGIN_SRC emacs-lisp
(after! (tex-mode smartparens)
  (sp-with-modes '(tex-mode
                   plain-tex-mode
                   latex-mode
                   LaTeX-mode)
    (sp-local-pair "\"`" "\"'"          ; German quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\"<" "\">"          ; French quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\\(" "\\)" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-local-pair "\\[" "\\]" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))))
#+END_SRC

** Lisp
A common hook for all lisp modes.
#+BEGIN_SRC emacs-lisp
(defvar lisp-mode-common-hook nil
  "Hook called by all Lisp modes for common initialization.")

(defun lisp-mode-common-hook (&rest args)
  "Run all functions in `lisp-mode-common-hook' with ARGS."
  (apply #'run-hook-with-args 'lisp-mode-common-hook args))

(add-hook!
 '(clojure-mode-hook
   lisp-mode-hook
   lisp-interaction-mode-hook
   emacs-lisp-mode-hook
   fennel-mode-hook
   scheme-mode-hook)
 #'lisp-mode-common-hook)
#+END_SRC

Improve the comment insertion of ~comment-dwim~.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'lisp-mode-common-hook
  comment-start "; "
  comment-start-skip ";+\\s-*"
  +fmt-formatter #'indent-region)
#+END_SRC

*** Common Lisp
The file extension =.cl= is sometimes used.
#+BEGIN_SRC emacs-lisp
(push '("\\.cl\\'" . lisp-mode) auto-mode-alist)
#+END_SRC

Configure some of the common Interpreters for =sly=.
#+BEGIN_SRC emacs-lisp
(after! sly
  (setq sly-default-lisp 'sbcl)
  (when (executable-find "cmucl")
    (push '(cmucl ("cmucl")) sly-lisp-implementations))
  (when (executable-find "clisp")
    (push '(clisp ("clisp")) sly-lisp-implementations))
  (when (executable-find "sbcl")
    (push '(sbcl ("sbcl") :coding-system utf-8-unix) sly-lisp-implementations)))
#+END_SRC

*** Emacs Lisp
#+BEGIN_SRC emacs-lisp
(set-keymap-parent lisp-interaction-mode-map emacs-lisp-mode-map)
#+END_SRC

*** Scheme
On Arch, the [[https://www.call-cc.org/][Chicken Scheme]] binaries are called =chicken-csi= and =chicken-csc=.
#+BEGIN_SRC emacs-lisp
(after! geiser-chicken
  (when (executable-find "chicken-csi")
    (setq geiser-chicken-binary "chicken-csi")))
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
(after! lua-mode
  (defvaralias 'lua-indent-level 'indent-level)
  (setq-hook! 'lua-mode-hook
    indent-level 2
    tab-width 2
    indent-tabs-mode t
    +fmt-formatter #'luaformatter-format-region))
#+END_SRC

Doom advises ~newline-and-indent~ to continue comments using the value of
~comment-line-break-function~. The standard value is ~comment-indent-new-line~,
which is broken in Lua's multiline comments.
#+BEGIN_SRC emacs-lisp
(after! lua-mode
  (defun *lua-comment-indent-new-line (&optional soft)
    "Break line at point and indent, continuing a series of line comments."
    (interactive)
    (if (or (not (lua-comment-or-string-p))
            (lua-string-p)
            (not (save-excursion
                   (goto-char (lua-comment-or-string-start-pos))
                   (looking-at-p "--\\[=*\\["))))
        (comment-indent-new-line soft)
      (delete-horizontal-space t)
      (newline nil t)
      (indent-according-to-mode)))

  (setq-hook! 'lua-mode-hook
    comment-line-break-function #'*lua-comment-indent-new-line))
#+END_SRC

#+RESULTS:

*** Company
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion company)
  (after! company-lua (setq company-lua-interpreter 'lua53)))
#+END_SRC

*** NOTE Comment deletion broken
The advice ~+default--delete-backward-char-a~ to ~backward-delete-char~ behaves
weirdly when deleting line comments inside of a multiline comment. I have not
yet found a fix for this.

** Moonscript
We are currently limited by ~moonscript-indent-line~, which doesn’t
respect ~indent-tabs-mode~.
#+BEGIN_SRC emacs-lisp
(after! moonscript
  (defvaralias 'moonscript-indent-offset 'indent-level)
  (setq-hook! 'moonscript-mode-hook
    indent-level 2
    tab-width 8
    indent-tabs-mode nil))
#+END_SRC

Doom Emacs, annoyingly, sets ~moonscript-indent-offset~ to ~tab-width~ by default.
#+BEGIN_SRC emacs-lisp
(after! moonscript
  (remove-hook
   'moonscript-mode-hook
   #'doom--setq-moonscript-indent-offset-for-moonscript-mode-h))
#+END_SRC
** Org
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-cycle-global-at-bob t
        org-cycle-include-plain-lists nil
        org-directory (expand-file-name "~/text/org/"))
        org-startup-folded t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! org
  ;; For some reason, `show-smartparens-mode' causes visual glitches.
  (add-hook 'org-mode-hook #'turn-off-show-smartparens-mode)
  ;; Use hard line wrapping to keep all columns shorter than `fill-column'.
  (add-hook! 'org-mode-hook #'turn-off-visual-line-mode #'auto-fill-mode)
  ;; Don’t start `flyspell-mode' automatically.
  (remove-hook 'org-mode-hook #'flyspell-mode)
  (when EMACS27+
    (add-hook 'org-mode-hook #'display-fill-column-indicator-mode--turn-off)))
#+END_SRC

*** Modules
These values have to be set before ~org-mode~ is loaded.
#+BEGIN_SRC emacs-lisp
(unless (memq 'org doom-disabled-packages)
  (setq org-modules
        '(;; ol-w3m
          ;; ol-bbdb
          ol-bibtex
          ;; ol-docview
          ;; ol-gnus
          ol-info
          ;; ol-irc
          ;; ol-mhe
          ;; ol-rmail
          ;; ol-eww
          )))
#+END_SRC

*** Languages
#+BEGIN_SRC emacs-lisp
(after! org-src
  (push! org-src-lang-modes
         '("dash" . sh)
         '("zsh"  . sh)))
#+END_SRC

*** Keybindings
Bind shortcuts for navigating headings with the arrow keys.
#+BEGIN_SRC emacs-lisp
(map! :after org
      :map org-mode-map
      "C-M-<left>"  #'org-up-element
      "C-M-<right>" #'org-down-element
      "C-M-<up>"    #'org-previous-visible-heading
      "C-M-<down>"  #'org-next-visible-heading)
#+END_SRC

Add ~org-babel-map~ to ~:localleader~.
#+BEGIN_SRC emacs-lisp
(map! :after org-keys
      :map org-mode-map
      :localleader
      :prefix ("v" . "babel") "" org-babel-map)
#+END_SRC


*** Company
Add ~company-capf~ as a Company backend.
#+BEGIN_SRC emacs-lisp
(after! org (set-company-backend! 'org-mode 'company-capf))
#+END_SRC

*** Smartparens
#+BEGIN_SRC emacs-lisp
(after! (org smartparens)
  (sp-with-modes '(org-mode)
    (sp-local-pair "=" "=")
    (sp-local-pair "~" "~")))
#+END_SRC

*** Which Key
#+BEGIN_SRC emacs-lisp
(after! (org which-key)
  (which-key-add-major-mode-key-based-replacements 'org-mode
    "C-c C-x" "more"
    "C-c C-v" "babel"
    "C-c \""  "plot"))
#+END_SRC

** Pascal
#+BEGIN_SRC emacs-lisp
(after! pascal
  (defvaralias 'pascal-indent-level 'indent-level)
  (defvaralias 'pascal-case-indent  'indent-level))

(after! opascal
  (defvaralias 'opascal-indent-level 'indent-level)
  (defvaralias 'opascal-case-indent  'indent-level))

(after! (:or pascal opascal)
  (setq-hook! '(pascal-mode-hook opascal-mode-hook)
    indent-level 3
    tab-width 3
    indent-tabs-mode t
    +fmt-formatter #'ptop-format-region))
#+END_SRC

*** Company
We have to remove ~company-capf~ from ~company-backends~, because completion
would be unusable otherwise.
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion company)
  (after! (:or pascal-mode opascal-mode)
    (setq-hook! '(pascal-mode-hook opascal-mode-hook)
      company-backends (remq 'company-capf company-backends))))
#+END_SRC

** Perl
Set indentation to 4 in both Perl modes.
#+BEGIN_SRC emacs-lisp
(after!  perl-mode (defvaralias  'perl-indent-level 'indent-level))
(after! cperl-mode (defvaralias 'cperl-indent-level 'indent-level))
(after! (:or perl-mode cperl-mode)
  (setq-hook! 'cperl-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'perltidy-format-region))
#+END_SRC

** PHP
This allows me to not load the entire =:lang/php= module.
#+BEGIN_SRC emacs-lisp
(unless (featurep! :lang php) (use-package! php-mode :defer t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! php-mode
  (defvaralias 'c-basic-offset 'indent-level)
  (setq-hook! 'php-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'prettier-format-region))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(after! python
  (defvaralias 'python-indent-offset 'indent-level)
  (setq-hook! 'python-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode nil
    +fmt-formatter #'black-format-buffer))
#+END_SRC

*** Company
[[https://jedi.readthedocs.io/en/latest/][Jedi]] gives the best (non LSP) autocompletion for python.
[[https://github.com/syohex/emacs-company-jedi][=company-jedi=]] is a backend for =company= that interfaces with Jedi.
This adds ='company-jedi= to =company-backends= in Python buffers.
The package will load when =company-jedi= is invoked by =company=.
#+BEGIN_SRC emacs-lisp
(use-package! company-jedi
  :when (featurep! :completion company)
  :after (python company)
  :defer t
  :config (set-company-backend! 'python-mode 'company-jedi))
#+END_SRC

*** Which Key
#+BEGIN_SRC emacs-lisp
(after! (python which-key)
  (which-key-add-major-mode-key-based-replacements 'python-mode
    "C-c C-p" "pipenv"
    "C-c C-t" "skeleton"))
#+END_SRC

*** _Backup
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
Use system =mspyls= for =lsp-python-ms=.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :lang python +lsp)
  (after! lsp-python-ms
    (setq lsp-python-ms-dir "/usr/lib/microsoft-python-language-server"
          lsp-python-ms-executable "/usr/bin/mspyls")))
#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp
(after! rustic
  (defvaralias 'rustic-indent-offset 'indent-level)
  (setq-hook! '(rustic-mode-hook rustic-macro-expansion-mode-hook)
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'rustic-format-buffer))
#+END_SRC

The [[https://github.com/rust-analyzer/rust-analyzer][rust-analyzer]] is an experimental language server and is to become
the successor to RLS.
#+BEGIN_SRC emacs-lisp
(after! rustic
  (when (executable-find "rust-analyzer")
    (setq rustic-lsp-server 'rust-analyzer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! rustic
  (defadvice! *rustic--rustfmt-respect-indent-tabs-mode-a (orig-fn &rest args)
    "Make `rustic-format-buffer' respect `indent-tabs-mode'."
    :around #'rustic-format-buffer
    (let ((rustic-rustfmt-config-alist
           (cons (cons 'hard_tabs indent-tabs-mode)
                 rustic-rustfmt-config-alist)))
      (apply orig-fn args))))
#+END_SRC

** Shell
#+BEGIN_SRC emacs-lisp
(after! sh-script
  (defvaralias 'sh-basic-offset 'indent-level)
  (setq-hook! sh-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'shfmt-format-region))
#+END_SRC

** XML
#+BEGIN_SRC emacs-lisp
(after! nxml-mode
  (setq-hook! 'nxml-mode-hook
    indent-level 2
    tab-width 8
    indent-tabs-mode nil
    +fmt-formatter #'tidy-format-region))
#+END_SRC

Make the indentation inside of comments respect ~nxml-child-indent~.
#+BEGIN_SRC emacs-lisp
(after! nxml-mode
  (defadvice! *nxml--indent-correctly-inside-comments-a
    (orig-fn pos open-delim close-delim)
    :around #'nxml-compute-indent-in-delimited-token
    (let ((indent (funcall orig-fn pos open-delim close-delim)))
      (when (and (string= "<!--" open-delim) (string= "-->" close-delim)
                 (progn (goto-char pos)
                        (back-to-indentation)
                        (not (looking-at-p "-->"))))
        (goto-char xmltok-start)
        (setq indent (+ (current-column) nxml-child-indent)))
      indent)))
#+END_SRC

Disable ~smartparens-mode~ because it it kind of useless in ~nxml-mode~.
#+BEGIN_SRC emacs-lisp
(after! nxml-mode (add-hook 'nxml-mode-hook #'turn-off-smartparens-mode))
#+END_SRC

*** Hideshow
Replace the original ~nxml-mode~ rules with ones that aren’t broken.
#+BEGIN_SRC emacs-lisp
(after! (nxml-mode hideshow)
  (assq-delete-all 'nxml-mode hs-special-modes-alist)
  (push! hs-special-modes-alist
         '(nxml-mode
           "<!--\\|<[^/>?][^>]*[^/]>"
           "-->\\|</[^>]*[^/]>"
           "<!--"
           sgml-skip-tag-forward
           nil)))
#+END_SRC

* Keybindings
** Ä/Ö/Ü
#+BEGIN_SRC emacs-lisp
(map! "C-ü" #'execute-extended-command)
(map! :map key-translation-map
      "C-ö" (kbd "C-x")
      "C-ä" (kbd "C-c"))
#+END_SRC

** Copy/Paste
Use C-p to paste.
#+BEGIN_SRC emacs-lisp
(map! :i "C-p" #'yank
      :i "M-p" #'yank-pop)
#+END_SRC

** Undo/Redo
Bind keys for ~redo~.
#+BEGIN_SRC emacs-lisp
(map! "<redo>" #'redo
      :n "U" #'redo)
#+END_SRC

** Folding
Completely remap the ~+fold~ commands, making use of =h= as a prefix.
This frees up =z r= =z m=.
#+BEGIN_SRC emacs-lisp
(map! :when (and (featurep! :editor evil)
                 (featurep! :editor fold))
      :n "z O" #'+fold/open-all
      :n "z C" #'+fold/close-all

      :mn "h" nil
      :n "h h" #'+fold/toggle
      :n "h t" #'+fold/toggle
      :n "h a" #'+fold/toggle
      :n "h o" #'+fold/open
      :n "h O" #'+fold/open-all
      :n "h c" #'+fold/close
      :n "h C" #'+fold/close-all
      :m "h n" #'+fold/next
      :m "h p" #'+fold/previous)
#+END_SRC

** Leader Extensions
It is handy to have ~negative-argument~ on a binding
similar to that of ~universal-argument~.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Negative Argument" "-" #'negative-argument)
#+END_SRC

Bind ~shell-command~ in a similar way to =M-x= and =M-;=.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Shell command" "!" #'shell-command)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "b"
      :desc "Rename buffer" "R" #'rename-buffer)
#+END_SRC

Bind ~indent-region~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "c"
      :desc "Indent buffer/region" "i" #'indent-region
      ;; We need to move this out of the way.
      (:when (featurep! :tools lsp)
       :desc "LSP Organize imports" "I" #'lsp-organize-imports))
#+END_SRC

Bind mnemonics for =git add=.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "g"
      (:when (featurep! :ui vc-gutter)
       :desc "Git add hunk" "a" #'git-gutter:stage-hunk
       :desc "Diff hunk"    "d" #'git-gutter:popup-hunk)
      (:when (featurep! :tools magit)
       :desc "Git add file" "A" #'magit-stage-file))
#+END_SRC

Bind ~auto-fill-mode~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "t"
      :desc "Hard line wrapping" "W" #'auto-fill-mode)
#+END_SRC

** _Backup
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:

Some stuff I don't use anymore.
#+BEGIN_SRC emacs-lisp
(map! :leader :desc "List buffers" "b L" #'list-buffers)
(map! "<mouse-8>" #'backward-page
      "<mouse-9>" #'forward-page)
(map! :m "C-e" nil)
#+END_SRC
