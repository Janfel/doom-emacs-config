#+TITLE: Doom Emacs Configuration
#+DESCRIPTION: Doom Emacs configuration of Jan Felix Langenbach
#+AUTHOR: Jan Felix Langenbach
#+EMAIL: o.hase3@gmail.com

* Introduction
These are some useful links to manuals and other peoples configs.

+ [[https://www.gnu.org/software/emacs/manual][Emacs Manual]]
+ [[https://github.com/seagle0128/.emacs.d][Centaur Emacs]]
+ [[https://github.com/hlissner/doom-emacs][Doom Emacs]]
+ [[https://github.com/MatthewZMD/.emacs.d][M-Emacs]]
+ [[https://github.com/poncie/.emacs.d][Poncie's Config]]
+ [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Config]]

** Header
This header comment ensures that everything in this file is lexically scoped.
#+BEGIN_SRC emacs-lisp
;;; doom/config.el -*- lexical-binding: t; -*-
#+END_SRC

** Requires

*** [[https://github.com/magnars/dash.el][dash.el]]
A modern list library inspired by Clojure.
#+BEGIN_SRC emacs-lisp
(require 'dash)
#+END_SRC

*** [[https://github.com/purcell/reformatter.el][reformatter.el
]]A library for creating formatting functions.
#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (require 'reformatter))
#+END_SRC

* Definitions
** Functions and Macros
#+BEGIN_SRC emacs-lisp
(defun string-or (&rest strings)
  "Return the first non-nil and non-empty string in STRINGS."
  (cl-dolist (s strings)
    (when (and s (not (string-empty-p s)))
      (cl-return s))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defmacro push! (place &rest values)
  "Push VALUES into PLACE."
  `(setf ,place (append (list ,@values) ,place)))
#+END_SRC

** Constants
These constants allow me to use the correct directories everywhere,
without lengthy invocation of =getenv=.
#+BEGIN_SRC emacs-lisp
(defconst XDG-CACHE-HOME
  (-> (getenv "XDG_CACHE_HOME")
      (string-or "~/.cache/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CACHE_HOME where programs place cache files.")

(defconst XDG-CONFIG-HOME
  (-> (getenv "XDG_CONFIG_HOME")
      (string-or "~/.config/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_CONFIG_HOME where programs place configuration files.")

(defconst XDG-DATA-HOME
  (-> (getenv "XDG_DATA_HOME")
      (string-or "~/.local/share/")
      (file-name-as-directory)
      (expand-file-name))
  "The value of $XDG_DATA_HOME where programs store data.")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defconst SYSTEM
  (let ((sysname (system-name)))
    (cond ((string= sysname "PhantomJFL") 'Phantom)
          ((string= sysname "TeslaJFL")   'Tesla)
          (t 'other)))
  "Which system are we running on?")
#+END_SRC

I redefine the operating system constants of Doom Emacs to give them docstrings.
#+BEGIN_SRC emacs-lisp
(defconst IS-LINUX IS-LINUX
  "Are we on a Linux system?")

(defconst IS-MAC IS-MAC
  "Are we on a Mac?")

(defconst IS-WINDOWS IS-WINDOWS
  "Are we on a Windows system?")

(defconst IS-BSD IS-BSD
  "Are we on a BSD system?")
#+END_SRC

* Emacs
Don’t untabify when deleting a tab character.
#+BEGIN_SRC emacs-lisp
(setq backward-delete-char-untabify-method nil)
#+END_SRC

Make the block cursor stretch to highlight tab characters.
#+BEGIN_SRC emacs-lisp
(setq x-stretch-cursor t)
#+END_SRC

** Indentation
Disable tab insertion by default.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC

Control the width of a tab character.
#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

Indentation in Emacs is a mess currently. Each mode defines its own variables.
This consolidates indentation into one single variable.
#+BEGIN_SRC emacs-lisp
(defvar-local indent-level 4
  "Indentation level for all major-modes.")

(defvaralias 'standard-indent 'indent-level)
#+END_SRC

These functions have a tendency to insert tabs where they don’t belong.
#+BEGIN_SRC emacs-lisp
(defadvice! config--disable-indent-tabs-mode-a (orig-fn &rest args)
  "Let `indent-tabs-mode' be bound to nil."
  :around '(align-areas indent-relative comment-indent)
  (let (indent-tabs-mode) (apply orig-fn args)))
#+END_SRC

* Doom
** Core
Don’t turn on ~whitespace-mode~ automatically.
#+BEGIN_SRC emacs-lisp
(defadvice! config--disable-automatic-whitespace-mode-a (&rest _)
  "Don’t turn on `whitespace-mode' on startup."
  :after #'doom-init-ui-h
  (remove-hook 'after-change-major-mode-hook
               #'doom-highlight-non-default-indentation-h))
#+END_SRC


** Fmt
Here I replace the default formatting function with my own.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor fmt)
      :nv "g =" #'+fmt:region
      :map doom-leader-code-map
      :desc "Format buffer/region" "f" #'+fmt/dwim)
#+END_SRC

** Fold
Map opening and closing all folds to Shift combinations.
This frees up =z r= =z m=.
#+BEGIN_SRC emacs-lisp
(map! :when (and (featurep! :editor evil)
                 (featurep! :editor fold))
      :n "z O" #'+fold/open-all
      :n "z C" #'+fold/close-all)
#+END_SRC

* Packages
** Emacs
These packages are built into Emacs itself.

*** HideShow
#+BEGIN_SRC emacs-lisp
(map! :map 'hs-minor-mode-map
      :leader :prefix ("c h" . "Hide code")
      :desc "Toggle hiding"    "h" #'hs-toggle-hiding
      :desc "Hide all"         "a" #'hs-hide-all
      :desc "Show all"         "A" #'hs-show-all
      :desc "Hide block"       "b" #'hs-hide-block
      :desc "Show block"       "B" #'hs-show-block
      :desc "Hide level"       "l" #'hs-hide-level
      :desc "Hide top comment" "c" #'hs-hide-initial-comment-block)
#+END_SRC

*** Info
Treat ~info~ buffers as real buffers.
#+BEGIN_SRC emacs-lisp
(after! info (set-popup-rule! "^\\*info\\*$" :ignore))
#+END_SRC

*** Whitespace
#+BEGIN_SRC emacs-lisp
(setq whitespace-style
      '(face
        indentation
        lines-tail
        empty
        tabs
        tab-mark
        space-before-tab
        space-after-tab))
#+END_SRC

** Doom
These packages are used in the =:core= of Doom Emacs.
That means we don't need =featurep!=.

*** Helpful
Some function definitions contain tab character that are
assumed to be eight spaces wide.
#+BEGIN_SRC emacs-lisp
(after! helpful
  (setq-hook! 'helpful-mode-hook
    tab-width 8
    x-stretch-cursor nil))
#+END_SRC

*** Which Key
These are some default keybindings that are missing a description.
#+BEGIN_SRC emacs-lisp
(after! which-key
  (which-key-add-key-based-replacements
    "C-x"      '("global" . "Global commands")
    "C-x RET"  "locale"
    "C-x ESC"  "complex-repeat"
    "C-x 4"    "other-window"
    "C-x 5"    "other-frame"
    "C-x 6"    "two-column"
    "C-x 8"    '("unicode" . "Unicode symbols")
    "C-x @"    '("apply-modifier" . "Add a modifier to the next event")
    "C-x a"    "abbrev"
    "C-x a i"  "inverse"
    "C-x v"    "version-control"
    "C-x n"    "narrow"
    "C-x r"    "rectangle/register"
    "C-c"      '("mode-specific" . "Mode specific commands")
    "M-s"      "search"
    "M-s h"    "highlight"
    "M-g"      "goto")

  (push! which-key-replacement-alist
         '(("<up>"   . nil) . ("↑" . nil))
         '(("<down>" . nil) . ("↓" . nil))))
#+END_SRC

*** WS Butler
In =snippet-mode=, whitespace has significant meaning.
#+BEGIN_SRC emacs-lisp
(after! ws-butler
  (push 'snippet-mode ws-butler-global-exempt-modes))
#+END_SRC



** Evil
Evil uses Vims undo increments by default, which are too coarse for me.
#+BEGIN_SRC emacs-lisp
(when (featurep! :editor evil)
  (setq evil-want-fine-undo t
        ;; This seems to be broken.
        evil-indent-convert-tabs nil))
#+END_SRC

Consolidate indentation.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :editor evil)
  (defvaralias 'evil-shift-width 'indent-level))
#+END_SRC

*** Bindings
Map the arrow keys in Evils window map.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil
      :map evil-window-map
      "<up>"      #'evil-window-up
      "<down>"    #'evil-window-down
      "<left>"    #'evil-window-left
      "<right>"   #'evil-window-right
      "S-<up>"    #'+evil/window-move-up
      "S-<down>"  #'+evil/window-move-down
      "S-<left>"  #'+evil/window-move-left
      "S-<right>" #'+evil/window-move-right
      "C-h"       nil
      "C-j"       nil
      "C-k"       nil
      "C-l"       nil)
#+END_SRC

Remap the document scroll motions to something more sensible.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil
      :m "z+" nil
      :m "z-" nil
      :m "z^" nil
      :m "z." nil
      :m "zT" #'evil-scroll-bottom-line-to-top
      :m "zB" #'evil-scroll-top-line-to-bottom
      :m "z S-<right>" #'evil-scroll-right
      :m "z S-<left>" #'evil-scroll-left)
#+END_SRC

*** Collection
I don't like my games to use Vim keys. This has to be so complicated because
Doom loads =evil-collection= manually. The ~push!~ is executed right before
~+evil-collection-init~ is first called.
#+BEGIN_SRC emacs-lisp
(when (and (featurep! :editor evil +everywhere)
           doom-interactive-p
           (not doom-reloading-p)
           (not (memq 'evil-collection doom-disabled-packages)))
  (add-transient-hook! #'+evil-collection-init
    (push! +evil-collection-disabled-list
           'tetris '2084-game 'haskell-error-mode)))
#+END_SRC

*** Numbers
Remap the ~inc-at-pt~ functions, so =z == can be used for formatting.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-numbers
      :nv "g +" #'evil-numbers/inc-at-pt
      :nv "g -" #'evil-numbers/dec-at-pt
      :v "z +" #'evil-numbers/inc-at-pt-incremental
      :v "z -" #'evil-numbers/dec-at-pt-incremental)
#+END_SRC

*** Snipe
Put ~evil-snipe-repeat~ on Comma and Shift-Comma.
Doesn’t seem to work due to keymap precedences.
#+BEGIN_SRC emacs-lisp :tangle no
(map! :when (featurep! :editor evil)
      :after evil
      :map evil-snipe-parent-transient-map
      "," #'evil-snipe-repeat
      "–" #'evil-snipe-repeat-reverse
      ";" nil)
#+END_SRC

*** Org
Doom Emacs changes ~org-cycle~ to skip the ~'subtree~ stage by default when
~(featurep! :editor evil +everywhere)~.
#+BEGIN_SRC emacs-lisp
(when! (featurep! :editor evil +everywhere)
  (after! evil-org
    (remove-hook 'org-tab-first-hook #'+org-cycle-only-current-subtree-h)))
#+END_SRC

Add block jumping to =[= and =]=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-org
      :map evil-org-mode-map
      :m "[ _" #'org-previous-block
      :m "] _" #'org-next-block)
#+END_SRC

Remap =z r= and =z m= to =z O= and =z C=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :editor evil)
      :after evil-org
      :map evil-org-mode-map
      :n "z r" nil
      :n "z m" nil
      :n "z O" #'+org/show-next-fold-level
      :n "z C" #'+org/hide-next-fold-level)
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :checkers syntax)
      :after flycheck
      (:leader :prefix "c"
        (:prefix ("!" . "flycheck") "" flycheck-command-map))
      (:map flycheck-command-map
        "!" #'flycheck-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(when! (featurep! :checkers syntax)
  (after! which-key
    (which-key-add-key-based-replacements
      "C-c !" "flycheck")))
#+END_SRC

** Ivy
Don't show =../= in file completion buffer.
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion ivy)
  (setq ivy-extra-directories '("./")))
#+END_SRC

Ivy should recurse into directories when pressing =RET=.
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :completion ivy)
      :after ivy
      :map ivy-minibuffer-map
      "<return>"   #'ivy-alt-done
      "C-<return>" #'ivy-immediate-done
      "C-l"        #'ivy-done
      "C-<up>"     #'ivy-previous-history-element
      "C-<down>"   #'ivy-next-history-element)
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
(when (and (featurep! :checkers syntax)
           (featurep! :tools lsp))
  (setq lsp-prefer-flymake nil))
#+END_SRC

** Neotree
#+BEGIN_SRC emacs-lisp
(map! :when (featurep! :ui neotree)
      :after neotree
      :map neotree-mode-map
      :n "<tab>" #'neotree-quick-look)
#+END_SRC

** Smartparens
This is currently broken, in that two closing
delimiters are deleted instead of one.
#+BEGIN_SRC emacs-lisp
(when (featurep! :config default +smartparens)
  (setq sp-autodelete-pair nil))
#+END_SRC

I activate ~show-smartparens-global-mode~ to highlight matching parens.
#+BEGIN_SRC emacs-lisp
(when (featurep! :config default +smartparens)
  (after! smartparens (show-smartparens-global-mode +1)))
#+END_SRC

** Undo Tree
When =undo-tree= is allowed to automatically save the undo history, it somehow
chokes on an empty undo list and interrupts us with constant errors.
#+BEGIN_SRC emacs-lisp
(when (featurep! :emacs undo +tree)
  (setq undo-tree-auto-save-history nil))
#+END_SRC

** Yasnippet
#+BEGIN_SRC emacs-lisp
(when! (featurep! :editor snippets)
  (after! which-key
    (which-key-add-key-based-replacements
      "C-c &" "snippet")))
#+END_SRC



** Misc
The package [[https://github.com/DarthFennec/highlight-indent-guides][highlight-indent-guides]] draws a line for each indentation level.
#+BEGIN_SRC emacs-lisp
(use-package! highlight-indent-guides
  ;; Maybe change this to mode-by-mode basis.
  :commands (highlight-indent-guides-mode)
  :config
  (setq highlight-indent-guides-method 'bitmap
        highlight-indent-guides-bitmap-function
        #'highlight-indent-guides--bitmap-line
        highlight-indent-guides-responsive 'top))
#+END_SRC

These functions delete all whitespace up to the next non-whitespace character.
#+BEGIN_SRC emacs-lisp
(use-package! hungry-delete
  :bind (("M-DEL"      . hungry-delete-backward)
         ("M-<delete>" . hungry-delete-forward)))
#+END_SRC

This mode displays instances of =^L= (form feed) as horizontal lines.
#+BEGIN_SRC emacs-lisp
(use-package! form-feed
  :hook ((prog-mode text-mode) . form-feed-mode))
#+END_SRC

* Languages
** Assembler
#+BEGIN_SRC emacs-lisp
(after! asm-mode
  (defadvice! config--add-asm-mode-indentation-rules-a (&rest _)
    "Add rule clauses to `asm-calculate-indentation'."
    :before-until #'asm-calculate-indentation
    (and (looking-at "section") 0)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! asm-mode
  (setq-hook! 'asm-mode-hook
    tab-width 8
    indent-tabs-mode t))
#+END_SRC

** C/C++
*** TODO Code Style
The default is =doom=.
I have yet to create my own style.
#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl"
               '("linux"
                 (indent-tabs-mode . t)
                 (c-basic-offset   . 4)
                 (tab-width        . 4)))
  (setq c-default-style
        '((java-mode . "java")
          (awk-mode  . "awk")
          ;; (other     . "k&r")
          (other     . "jfl")
          )))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(after! cc-mode
  (c-add-style "jfl" '("linux"
                       (indent-tabs-mode . t)
                       (tab-width . 4)
                       (c-basic-offset . 4)))
  (if (listp c-default-style)
      (setf (alist-get 'other c-default-style) "jfl")
    (setq c-default-style "jfl")))
#+END_SRC

*** Arduino
#+BEGIN_SRC emacs-lisp
(after! arduino
  (setq arduino-mode-home (expand-file-name "~/src/arduino/")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! ede-arduino
  (let ((arduino-dir (expand-file-name "arduino/" XDG-DATA-HOME)))
    (when (file-directory-p arduino-dir)
      (setq ede-arduino-preferences-file
            (expand-file-name "preferences.txt" arduino-dir)))))
#+END_SRC

*** C
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! cc-mode
    (setq-hook! 'c-mode-hook
      flycheck-gcc-language-standard   "gnu18"
      flycheck-clang-language-standard "gnu18")))
#+END_SRC

*** C++
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! cc-mode
    (setq-hook! 'c++-mode-hook
      flycheck-gcc-language-standard   "gnu++17"
      flycheck-clang-language-standard "gnu++17")))
#+END_SRC

*** Meson
Major mode for the [[https://mesonbuild.com][Meson Build System]].
#+BEGIN_SRC emacs-lisp
(use-package! meson-mode :defer t)
#+END_SRC

** Haskell
These bindings are used by many modes with an inferior REPL.
#+BEGIN_SRC emacs-lisp
(map! :after haskell-mode
      :map haskell-mode-map
      "C-c C-c" #'haskell-process-load-file
      "C-c C-z" #'haskell-interactive-switch)
#+END_SRC

*** Flycheck
Flycheck raises a "Suspicious State" error when the linter exits with a nonzero
error code. Using =--no-exit-code= prevents this.
#+BEGIN_SRC emacs-lisp
(when (featurep! :checkers syntax)
  (after! haskell-mode
    (add-hook 'haskell-mode-hook #'flycheck-mode)
    (setq flycheck-hlint-args '("--no-exit-code"))))
#+END_SRC

*** Dante
#+BEGIN_SRC emacs-lisp
(when (featurep! :lang haskell +dante)
  (add-hook 'haskell-mode-hook #'dante-mode)
  (when (featurep! :checkers syntax)
    (after! (dante flycheck)
      (flycheck-add-next-checker 'haskell-dante '(warning . haskell-hlint)))))
#+END_SRC

** Javascript
#+BEGIN_SRC emacs-lisp
(after! js
  (defvaralias 'js-indent-level 'indent-level)
  (setq-hook! 'js-mode-hook
    indent-level 2
    tab-width 2
    indent-tabs-mode t
    +fmt-formatter #'prettier-format-region))
#+END_SRC

** TeX
Using =dvipng= is faster than =png= and is even recommended
in the [[info:preview-latex#Requirements][manual]] of =preview-latex=.
#+BEGIN_SRC emacs-lisp
(after! preview
  (when (executable-find "dvipng") (setq preview-image-type 'dvipng)))
#+END_SRC

*** LaTeX
Let Smartparens handle insertion of =$=.
#+BEGIN_SRC emacs-lisp
(map! :after tex-mode
      :map LaTeX-mode-map
      "$" nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! (tex-mode which-key)
  (which-key-add-major-mode-key-based-replacements 'latex-mode
    "C-c C-p"     '("preview" . "Inline formula preview")
    "C-c C-p C-c" "clear"
    "C-c C-o"     "fold"
    "C-c C-q"     "fill"
    "C-c C-t"     "toggle"))
#+END_SRC

This doesn't seem to work.
#+BEGIN_SRC emacs-lisp :tangle no
(after! tex-mode
  (add-hook 'LaTeX-mode-hook #'latex-electric-env-pair-mode))
#+END_SRC

Some Smartparens settings for LaTeX pairs.
Letting Smartparens handle these works best in my experience.
#+BEGIN_SRC emacs-lisp
(after! (tex-mode smartparens)
  (sp-with-modes '(tex-mode
                   plain-tex-mode
                   latex-mode
                   LaTeX-mode)
    (sp-local-pair "\"`" "\"'"          ; German quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\"<" "\">"          ; French quotes
                   :unless '(sp-latex-point-after-backslash sp-in-math-p)
                   :post-handlers '(sp-latex-skip-double-quote))
    (sp-local-pair "\\(" "\\)" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))
    (sp-local-pair "\\[" "\\]" :post-handlers '(("||\n[i]" "RET") ("| " "SPC")))))
#+END_SRC

** Lisp
A common hook for all lisp modes.
#+BEGIN_SRC emacs-lisp
(defvar lisp-mode-common-hook nil
  "Hook called by all Lisp modes for common initialization.")

(defun lisp-mode-common-hook (&rest args)
  "Run all functions in `lisp-mode-common-hook' with ARGS."
  (apply #'run-hook-with-args 'lisp-mode-common-hook args))

(add-hook!
 '(clojure-mode-hook
   lisp-mode-hook
   lisp-interaction-mode-hook
   emacs-lisp-mode-hook
   fennel-mode-hook
   scheme-mode-hook)
 #'lisp-mode-common-hook)
#+END_SRC

Improve the comment insertion of =comment-dwim=.
#+BEGIN_SRC emacs-lisp
(setq-hook! 'lisp-mode-common-hook
  comment-start "; "
  comment-start-skip ";+\\s-*")
#+END_SRC

Formatting for all Lisp modes.
#+BEGIN_SRC emacs-lisp
(when (featurep! :editor fmt)
  (setq-hook! 'lisp-mode-common-hook
    +fmt-formatter #'indent-region))
#+END_SRC

*** Common Lisp
The file extension =.cl= is sometimes used.
#+BEGIN_SRC emacs-lisp
(push '("\\.cl\\'" . lisp-mode) auto-mode-alist)
#+END_SRC

Configure some of the common Interpreters for =sly=.
#+BEGIN_SRC emacs-lisp
(after! sly
  (setq sly-default-lisp 'sbcl)
  (when (executable-find "cmucl")
    (push '(cmucl ("cmucl")) sly-lisp-implementations))
  (when (executable-find "clisp")
    (push '(clisp ("clisp")) sly-lisp-implementations))
  (when (executable-find "sbcl")
    (push '(sbcl ("sbcl") :coding-system utf-8-unix) sly-lisp-implementations)))
#+END_SRC

*** Emacs Lisp
#+BEGIN_SRC emacs-lisp
(set-keymap-parent lisp-interaction-mode-map emacs-lisp-mode-map)
#+END_SRC

*** Scheme
On Arch, the [[https://www.call-cc.org/][Chicken Scheme]] binaries are called =chicken-csi= and =chicken-csc=.
#+BEGIN_SRC emacs-lisp
(after! geiser-chicken
  (when (executable-find "chicken-csi")
    (setq geiser-chicken-binary "chicken-csi")))
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
(after! lua-mode
  (defvaralias 'lua-indent-level 'indent-level)
  (setq-hook! 'lua-mode-hook
    indent-level 2
    tab-width 2
    indent-tabs-mode t
    +fmt-formatter #'luaformatter-format-region))
#+END_SRC

Doom advises =newline-and-indent= to continue comments using the value of
=comment-line-break-function=. The standard value is =comment-indent-new-line=,
which is broken in Lua's multiline comments.
#+BEGIN_SRC emacs-lisp
(after! lua-mode
  (defun lua-comment-indent-new-line (&optional soft)
    "Break line at point and indent, continuing a series of line comments."
    (interactive)
    (if (or (not (lua-comment-or-string-p))
            (lua-string-p)
            (not (save-excursion
                   (goto-char (lua-comment-or-string-start-pos))
                   (looking-at-p "--\\[=*\\["))))
        (comment-indent-new-line soft)
      (delete-horizontal-space t)
      (newline nil t)
      (indent-according-to-mode)))

  (setq-hook! 'lua-mode-hook
    comment-line-break-function #'lua-comment-indent-new-line))
#+END_SRC

The advice =+default--delete-backward-char-a= to =backward-delete-char= behaves
weirdly when deleting line comments inside of a multiline comment. I have not
yet found a fix for this.

#+BEGIN_SRC emacs-lisp
(when (featurep! :completion company)
  (after! company-lua (setq company-lua-interpreter 'lua53)))
#+END_SRC

*** TODO Make Emacs not ignore =.lua-format= files.

** Moonscript
We are currently limited by =moonscript-indent-line=, which doesn’t
respect =indent-tabs-mode=.
#+BEGIN_SRC emacs-lisp
(after! moonscript
  (defvaralias 'moonscript-indent-offset 'indent-level)
  (setq-hook! 'moonscript-mode-hook
    indent-level 2
    tab-width 8
    indent-tabs-mode nil))
#+END_SRC

Doom Emacs, annoyingly, sets =moonscript-indent-offset= to =tab-width= by default.
#+BEGIN_SRC emacs-lisp
(after! moonscript
  (remove-hook
   'moonscript-mode-hook
   #'doom--setq-moonscript-indent-offset-for-moonscript-mode-h))
#+END_SRC

** Org
These values have to be set before =org-mode= is loaded.
#+BEGIN_SRC emacs-lisp
(unless (memq 'org doom-disabled-packages)
  (setq org-directory (expand-file-name "~/docs/org")
        org-modules
        '(;; ol-w3m
          ;; ol-bbdb
          ol-bibtex
          ;; ol-docview
          ;; ol-gnus
          ol-info
          ;; ol-irc
          ;; ol-mhe
          ;; ol-rmail
          ;; ol-eww
          )))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-cycle-global-at-bob t
        org-cycle-include-plain-lists nil
        org-startup-folded t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! org
  ;; Disable soft line wrapping.
  (add-hook! 'org-mode-hook (visual-line-mode -1))
  ;; Hard wrap lines that go over `fill-column'.
  (add-hook  'org-mode-hook #'auto-fill-mode)
  ;; Disable `show-smartparens-mode' as it
  ;; causes visual glitches in `org-mode'.
  (add-hook! 'org-mode-hook (show-smartparens-mode -1)))
#+END_SRC

Add =which-key= descriptions.
#+BEGIN_SRC emacs-lisp
(after! (org which-key)
  (which-key-add-major-mode-key-based-replacements 'org-mode
    "C-c C-x" "more"
    "C-c C-v" "babel"
    "C-c \""  "plot"))
#+END_SRC

Add ~company-capf~ as a Company backend.
#+BEGIN_SRC emacs-lisp
(after! org (set-company-backend! 'org-mode 'company-capf))
#+END_SRC

Add ~org-babel-map~ to ~:localleader~.
#+BEGIN_SRC emacs-lisp
(map! :after org-keys
      :map org-mode-map
      :localleader
      :prefix ("v" . "babel") "" org-babel-map)
#+END_SRC

** Pascal
#+BEGIN_SRC emacs-lisp
(after! pascal
  (defvaralias 'pascal-indent-level 'indent-level)
  (defvaralias 'pascal-case-indent  'indent-level))

(after! opascal
  (defvaralias 'opascal-indent-level 'indent-level)
  (defvaralias 'opascal-case-indent  'indent-level))

(after! (:or pascal opascal)
  (setq-hook! '(pascal-mode-hook opascal-mode-hook)
    indent-level 3
    tab-width 3
    indent-tabs-mode t
    +fmt-formatter #'ptop-format-region))
#+END_SRC

We have to remove ~company-capf~ from ~company-backends~, because completion
would be unusable otherwise.
#+BEGIN_SRC emacs-lisp
(when (featurep! :completion company)
  (after! (:or pascal-mode opascal-mode)
    (setq-hook! '(pascal-mode-hook opascal-mode-hook)
      company-backends (remq 'company-capf company-backends))))
#+END_SRC

** Perl
Set indentation to 4 in both Perl modes.
#+BEGIN_SRC emacs-lisp
(after!  perl-mode (defvaralias  'perl-indent-level 'indent-level))
(after! cperl-mode (defvaralias 'cperl-indent-level 'indent-level))
(after! (:or perl-mode cperl-mode)
  (setq-hook! 'cperl-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode t
    +fmt-formatter #'perltidy-format-region))
#+END_SRC

** PHP
This allows me to not load the entire =:lang php=.
#+BEGIN_SRC emacs-lisp
(unless (featurep! :lang php) (use-package! php-mode :defer t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! php-mode
  (setq-hook! 'php-mode-hook +fmt-formatter #'prettier-format-region))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(after! python
  (defvaralias 'python-indent-offset 'indent-level)
  (setq-hook! 'python-mode-hook
    indent-level 4
    tab-width 4
    indent-tabs-mode nil
    +fmt-formatter #'black-format-buffer))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(after! (python which-key)
  (which-key-add-major-mode-key-based-replacements 'python-mode
    "C-c C-p" "pipenv"
    "C-c C-t" "skeleton"))
#+END_SRC

Use system =mspyls= for =lsp-python-ms=.
#+BEGIN_SRC emacs-lisp :tangle no
(when (featurep! :lang python +lsp)
  (after! lsp-python-ms
    (setq lsp-python-ms-dir "/usr/lib/microsoft-python-language-server"
          lsp-python-ms-executable "/usr/bin/mspyls")))
#+END_SRC

[[https://jedi.readthedocs.io/en/latest/][Jedi]] gives the best (non LSP) autocompletion for python.
[[https://github.com/syohex/emacs-company-jedi][=company-jedi=]] is a backend for =company= that interfaces with Jedi.
This adds ='company-jedi= to =company-backends= in Python buffers.
The package will load when =company-jedi= is invoked by =company=.
#+BEGIN_SRC emacs-lisp
(use-package! company-jedi
  :when (featurep! :completion company)
  :after (python company)
  :defer t
  :config (set-company-backend! 'python-mode 'company-jedi))
#+END_SRC

* Keybindings
Bind ~sp-raise-sexp~, which I use quite often.
#+BEGIN_SRC emacs-lisp
(map! :n "z r" #'sp-raise-sexp)
#+END_SRC

Allows jumping from =^L= to =^L=.
#+BEGIN_SRC emacs-lisp
(map! "C-M-<next>"  #'forward-page
      "C-M-<prior>" #'backward-page)
#+END_SRC

Bind the Ä/Ö/Ü keys to something useful.
#+BEGIN_SRC emacs-lisp
(map! "C-ü" #'execute-extended-command)
(map! :map key-translation-map
      "C-ö" (kbd "C-x")
      "C-ä" (kbd "C-c"))
#+END_SRC

Use C-p to paste.
#+BEGIN_SRC emacs-lisp
(map! :i "C-p" #'yank
      :i "M-p" #'yank-pop)
#+END_SRC

Some stuff I don't use anymore.
#+BEGIN_SRC emacs-lisp :tangle no
(map! :leader :desc "List buffers" "b L" #'list-buffers)
(map! "<mouse-8>" #'backward-page
      "<mouse-9>" #'forward-page)
(map! :m "C-e" nil)
#+END_SRC

Bind keys for ~redo~.
#+BEGIN_SRC emacs-lisp
(map! "<redo>" #'redo
      :n "U" #'redo)
#+END_SRC

** Leader Extensions
It is handy to have ~negative-argument~ on a binding
similar to that of ~universal-argument~.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Negative Argument" "-" #'negative-argument)
#+END_SRC

Bind ~shell-command~ in a similar way to =M-x= and =M-;=.
#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Shell command" "!" #'shell-command)
#+END_SRC

Bind ~indent-region~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "c"
      :desc "Indent buffer/region" "i" #'indent-region
      ;; We need to move this out of the way.
      (:when (featurep! :tools lsp)
       :desc "LSP Organize imports" "I" #'lsp-organize-imports))
#+END_SRC

Bind mnemonics for =git add=.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "g"
      (:when (featurep! :ui vc-gutter)
       :desc "Git add hunk" "a" #'git-gutter:stage-hunk)
      (:when (featurep! :tools magit)
       :desc "Git add file" "A" #'magit-stage-file))
#+END_SRC

Bind ~auto-fill-mode~.
#+BEGIN_SRC emacs-lisp
(map! :leader :prefix "t"
      :desc "Hard line wrapping" "W" #'auto-fill-mode)
#+END_SRC
